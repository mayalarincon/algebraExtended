(normalizer_centralizer
 (IMP_group_action_TCC1 0
  (IMP_group_action_TCC1-1 nil 3799515121
   ("" (rewrite "fullset_is_group") nil nil)
   ((fullset_is_group formula-decl nil normalizer_centralizer nil)) nil
   (IMP_group_action assuming
    "group_action[normalizer_centralizer.T, normalizer_centralizer.*, normalizer_centralizer.one, normalizer_centralizer.T].group_action"
    "fullset_is_group: ASSUMPTION group_def[group_action.T, group_action.*, group_action.one].group?(sets[group_action.T].fullset)")))
 (normalizer_TCC1 0
  (normalizer_TCC1-1 nil 3530280384 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (set type-eq-decl nil sets nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (subgroup? const-decl "bool" group_def nil)
    (subgroup type-eq-decl nil group nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (inv_exists? const-decl "bool" group_def nil)
    (monoid? const-decl "bool" monoid_def nil)
    (associative? const-decl "bool" operator_defs nil)
    (monad? const-decl "bool" monad_def nil)
    (identity? const-decl "bool" operator_defs nil)
    (left_identity formula-decl nil monad nil)
    (restrict const-decl "R" restrict nil)
    (right_identity formula-decl nil monad nil)
    (one_member formula-decl nil monad nil)
    (star_closed? const-decl "bool" groupoid_def nil)
    (G!1 skolem-const-decl "group[T, *, one]" normalizer_centralizer
     nil)
    (extend const-decl "R" extend nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil))
   nil
   (normalizer subtype
    "extend[normalizer_centralizer.T, (normalizer_centralizer.G), booleans.bool, booleans.FALSE].extend({x: (normalizer_centralizer.G) | cosets[normalizer_centralizer.T, normalizer_centralizer.*, normalizer_centralizer.one].*(cosets[normalizer_centralizer.T, normalizer_centralizer.*, normalizer_centralizer.one].*(group[normalizer_centralizer.T, normalizer_centralizer.*, normalizer_centralizer.one].inv(x), normalizer_centralizer.H), x) = normalizer_centralizer.H})"
    "{S: sets[normalizer_centralizer.T].set | sets[normalizer_centralizer.T].subset?(S, normalizer_centralizer.G)}")))
 (centralizer_TCC1 0
  (centralizer_TCC1-1 nil 3530280384 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (set type-eq-decl nil sets nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (inv_exists? const-decl "bool" group_def nil)
    (monoid? const-decl "bool" monoid_def nil)
    (associative? const-decl "bool" operator_defs nil)
    (monad? const-decl "bool" monad_def nil)
    (identity? const-decl "bool" operator_defs nil)
    (left_identity formula-decl nil monad nil)
    (restrict const-decl "R" restrict nil)
    (right_identity formula-decl nil monad nil)
    (one_member formula-decl nil monad nil)
    (star_closed? const-decl "bool" groupoid_def nil)
    (G!1 skolem-const-decl "group[T, *, one]" normalizer_centralizer
     nil)
    (extend const-decl "R" extend nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil))
   nil
   (centralizer subtype
    "extend[normalizer_centralizer.T, (normalizer_centralizer.G), booleans.bool, booleans.FALSE].extend({x: (normalizer_centralizer.G) | normalizer_centralizer.*(x, normalizer_centralizer.a) = normalizer_centralizer.*(normalizer_centralizer.a, x)})"
    "{S: sets[normalizer_centralizer.T].set | sets[normalizer_centralizer.T].subset?(S, normalizer_centralizer.G)}")))
 (a_by_c_TCC1 0
  (a_by_c_TCC1-1 nil 3530280384
   ("" (skosimp*)
    (("" (typepred "h!1")
      (("" (typepred "H!1")
        (("" (hide -1)
          (("" (expand "subgroup?")
            (("" (expand* "subset?" "member")
              (("" (inst -1 "h!1")
                (("" (assert)
                  (("" (hide -2)
                    (("" (rewrite "product_in")
                      (("1" (rewrite "product_in") nil nil)
                       ("2" (rewrite "inv_in") nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subgroup type-eq-decl nil group nil)
    (subgroup? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (set type-eq-decl nil sets nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (product_in formula-decl nil group nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (inv_in formula-decl nil group nil))
   nil
   (a_by_c subtype
    "normalizer_centralizer.*(normalizer_centralizer.*(normalizer_centralizer.h, normalizer_centralizer.x), group[normalizer_centralizer.T, normalizer_centralizer.*, normalizer_centralizer.one].inv(normalizer_centralizer.h))"
    "(normalizer_centralizer.G)")))
 (CL_TCC1 0
  (CL_TCC1-1 nil 3530354396 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (set type-eq-decl nil sets nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (inv_exists? const-decl "bool" group_def nil)
    (monoid? const-decl "bool" monoid_def nil)
    (associative? const-decl "bool" operator_defs nil)
    (monad? const-decl "bool" monad_def nil)
    (identity? const-decl "bool" operator_defs nil)
    (left_identity formula-decl nil monad nil)
    (restrict const-decl "R" restrict nil)
    (right_identity formula-decl nil monad nil)
    (one_member formula-decl nil monad nil)
    (star_closed? const-decl "bool" groupoid_def nil)
    (G!1 skolem-const-decl "group[T, *, one]" normalizer_centralizer
     nil)
    (extend const-decl "R" extend nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil))
   nil
   (CL subtype
    "extend[normalizer_centralizer.T, (normalizer_centralizer.G), booleans.bool, booleans.FALSE].extend({y: (normalizer_centralizer.G) | EXISTS (g: (normalizer_centralizer.G)): y = normalizer_centralizer.*(normalizer_centralizer.*(g, normalizer_centralizer.x), group[normalizer_centralizer.T, normalizer_centralizer.*, normalizer_centralizer.one].inv(g))})"
    "{X: sets[normalizer_centralizer.T].set | sets[normalizer_centralizer.T].subset?(X, normalizer_centralizer.G)}")))
 (normalizer_is_subgroup 0
  (normalizer_is_subgroup-1 nil 3530280992
   ("" (skosimp*)
    (("" (lemma "subgroup_def")
      (("" (inst -1 "G!1" "normalizer(G!1,H!1)")
        (("" (assert)
          (("" (hide 2)
            (("" (prop)
              (("1" (expand "nonempty?")
                (("1" (expand "empty?")
                  (("1" (expand "member")
                    (("1" (inst - "one")
                      (("1" (expand "normalizer")
                        (("1" (expand "extend")
                          (("1" (ground)
                            (("1" (rewrite "left_coset_one")
                              (("1"
                                (rewrite "right_coset_one")
                                nil
                                nil))
                              nil)
                             ("2" (rewrite "one_in") nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "star_closed?")
                (("2" (expand "member")
                  (("2" (skosimp*)
                    (("2" (typepred "x!1" "y!1")
                      (("2" (expand "normalizer")
                        (("2" (expand "extend")
                          (("2" (ground)
                            (("1" (rewrite "inv_star")
                              (("1"
                                (hide (-1 -2 -4 -6))
                                (("1"
                                  (rewrite "right_coset_assoc" :dir rl)
                                  (("1"
                                    (rewrite
                                     "left_coset_assoc"
                                     :dir
                                     rl)
                                    (("1"
                                      (rewrite "lr_coset_assoc")
                                      (("1"
                                        (replace -2 1)
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide (-2 -4 -5))
                              (("2" (rewrite "product_in") nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (expand "inv_closed?")
                (("3" (skosimp*)
                  (("3" (expand "member")
                    (("3" (typepred "x!1")
                      (("3" (expand "normalizer")
                        (("3" (expand "extend")
                          (("3" (ground)
                            (("1" (replace -3 1 rl)
                              (("1"
                                (rewrite "lr_coset_assoc")
                                (("1"
                                  (rewrite "lr_coset_assoc")
                                  (("1"
                                    (rewrite "lr_coset_assoc")
                                    (("1"
                                      (rewrite "right_coset_assoc")
                                      (("1"
                                        (rewrite "right_coset_one")
                                        (("1"
                                          (rewrite "left_coset_assoc")
                                          (("1"
                                            (rewrite "left_coset_one")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide (-2 -3))
                              (("2" (rewrite "inv_in") nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((one formal-const-decl "T" normalizer_centralizer nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (subgroup_def formula-decl nil group nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (empty? const-decl "bool" sets nil)
    (extend const-decl "R" extend nil)
    (monad nonempty-type-eq-decl nil monad nil)
    (monad? const-decl "bool" monad_def nil)
    (one_in formula-decl nil monad nil)
    (left_coset_one formula-decl nil cosets nil)
    (right_coset_one formula-decl nil cosets nil)
    (inv_one formula-decl nil group nil)
    (member const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (product_in formula-decl nil group nil)
    (inv_star formula-decl nil group nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "set[T]" cosets nil)
    (right_coset_assoc formula-decl nil cosets nil)
    (lr_coset_assoc formula-decl nil cosets nil)
    (left_coset_assoc formula-decl nil cosets nil)
    (star_closed? const-decl "bool" groupoid_def nil)
    (inv_in formula-decl nil group nil)
    (* const-decl "set[T]" cosets nil)
    (inv_right formula-decl nil group nil)
    (inv_inv formula-decl nil group nil)
    (inv_closed? const-decl "bool" group nil)
    (normalizer const-decl "{S: set[T] | subset?(S, G)}"
     normalizer_centralizer nil)
    (subset? const-decl "bool" sets nil)
    (subgroup type-eq-decl nil group nil)
    (subgroup? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (subset_of_normalizer 0
  (subset_of_normalizer-1 nil 3530281053
   ("" (skosimp*)
    (("" (copy -1)
      (("" (expand "subgroup?" -1)
        (("" (expand* "subset?" "member")
          (("" (skosimp)
            (("" (inst?)
              (("" (assert)
                (("" (expand "normalizer")
                  (("" (expand "extend")
                    (("" (lemma "lc_is_eq")
                      (("" (inst -1 "G!1" "H!1" "inv(x!1)" "one")
                        (("" (assert)
                          (("" (prop)
                            (("1" (rewrite "left_coset_one")
                              (("1"
                                (replaces -1)
                                (("1"
                                  (lemma "rc_is_eq")
                                  (("1"
                                    (inst -1 "G!1" "H!1" "x!1" "one")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (prop)
                                        (("1"
                                          (rewrite "right_coset_one")
                                          nil
                                          nil)
                                         ("2"
                                          (hide (-1 -2 2))
                                          (("2" (inst?) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide (-1 -2 2))
                              (("2"
                                (inst 1 "inv(x!1)")
                                (("2"
                                  (lemma "inv_in")
                                  (("2" (inst -1 "H!1" "x!1") nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (normalizer const-decl "{S: set[T] | subset?(S, G)}"
     normalizer_centralizer nil)
    (lc_is_eq formula-decl nil cosets nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (left_identity formula-decl nil monad nil)
    (inv_in formula-decl nil group nil)
    (x!1 skolem-const-decl "T" normalizer_centralizer nil)
    (H!1 skolem-const-decl "group[T, *, one]" normalizer_centralizer
     nil)
    (left_coset_one formula-decl nil cosets nil)
    (rc_is_eq formula-decl nil cosets nil)
    (right_identity formula-decl nil monad nil)
    (right_coset_one formula-decl nil cosets nil)
    (TRUE const-decl "bool" booleans nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (extend const-decl "R" extend nil)
    (subgroup? const-decl "bool" group_def nil))
   shostak))
 (normal_in_normalizer_TCC1 0
  (normal_in_normalizer_TCC1-1 nil 3530280384
   ("" (skosimp)
    (("" (lemma "normalizer_is_subgroup")
      (("" (inst?)
        (("" (assert)
          (("" (expand "subgroup?") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((normalizer_is_subgroup formula-decl nil normalizer_centralizer
     nil)
    (subgroup? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil))
   nil
   (normal_in_normalizer subtype
    "normalizer_centralizer.normalizer(normalizer_centralizer.G, normalizer_centralizer.H)"
    "group[T, *, one]")))
 (normal_in_normalizer 0
  (normal_in_normalizer-1 nil 3530281087
   ("" (skosimp)
    (("" (expand "normal_subgroup?")
      (("" (prop)
        (("1" (expand "subgroup?" 1)
          (("1" (rewrite "subset_of_normalizer") nil nil)) nil)
         ("2" (skosimp)
          (("2" (typepred "a!1")
            (("2" (expand "normalizer")
              (("2" (expand "extend")
                (("2" (ground)
                  (("2" (decompose-equality -2)
                    (("2" (expand* "subset?" "member")
                      (("2" (skosimp)
                        (("2" (inst?)
                          (("2" (iff) (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((normal_subgroup? const-decl "boolean" normal_subgroups nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "set[T]" cosets nil)
    (* const-decl "set[T]" cosets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (extend const-decl "R" extend nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subgroup type-eq-decl nil group nil)
    (subset? const-decl "bool" sets nil)
    (normalizer const-decl "{S: set[T] | subset?(S, G)}"
     normalizer_centralizer nil)
    (subgroup? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (subset_of_normalizer formula-decl nil normalizer_centralizer nil))
   shostak))
 (centralizer_is_subgroup 0
  (centralizer_is_subgroup-1 nil 3530281149
   ("" (skosimp*)
    (("" (lemma "subgroup_def")
      (("" (inst?)
        (("" (assert)
          (("" (hide 2)
            (("" (prop)
              (("1" (expand "nonempty?")
                (("1" (expand "empty?")
                  (("1" (expand "member")
                    (("1" (inst - "one")
                      (("1" (grind) (("1" (rewrite "one_in") nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "centralizer")
                (("2" (expand "star_closed?")
                  (("2" (expand "member")
                    (("2" (skosimp*)
                      (("2" (typepred "x!1" "y!1")
                        (("2" (expand "extend")
                          (("2" (ground)
                            (("1" (hide (-1 -2 -4))
                              (("1"
                                (rewrite "assoc" :dir rl)
                                (("1"
                                  (replaces -1)
                                  (("1"
                                    (rewrite "assoc")
                                    (("1"
                                      (replaces -1)
                                      (("1"
                                        (rewrite "assoc" :dir rl)
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide (-2 -4))
                              (("2" (rewrite "product_in") nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (expand "inv_closed?")
                (("3" (skosimp*)
                  (("3" (expand "member")
                    (("3" (expand "centralizer")
                      (("3" (typepred "x!1")
                        (("3" (expand "centralizer")
                          (("3" (expand "extend")
                            (("3" (ground)
                              (("1"
                                (lemma "divby")
                                (("1"
                                  (inst -1 "a!1 * x!1" "x!1" "a!1")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (replace -1 1 rl)
                                      (("1"
                                        (rewrite "assoc" :dir rl)
                                        (("1"
                                          (rewrite "assoc" :dir rl)
                                          (("1"
                                            (replace -4 1 rl)
                                            (("1"
                                              (rewrite "assoc")
                                              (("1"
                                                (rewrite "assoc")
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (rewrite "inv_in") nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((one formal-const-decl "T" normalizer_centralizer nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (subgroup_def formula-decl nil group nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (empty? const-decl "bool" sets nil)
    (monad nonempty-type-eq-decl nil monad nil)
    (monad? const-decl "bool" monad_def nil)
    (one_in formula-decl nil monad nil)
    (left_identity formula-decl nil monad nil)
    (right_identity formula-decl nil monad nil)
    (extend const-decl "R" extend nil)
    (member const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (star_closed? const-decl "bool" groupoid_def nil)
    (product_in formula-decl nil group nil)
    (TRUE const-decl "bool" booleans nil)
    (assoc formula-decl nil group nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (FALSE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (inv_right formula-decl nil group nil)
    (inv_left formula-decl nil group nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (divby formula-decl nil group nil)
    (inv_in formula-decl nil group nil)
    (inv_closed? const-decl "bool" group nil)
    (centralizer const-decl "{S: set[T] | subset?(S, G)}"
     normalizer_centralizer nil)
    (subset? const-decl "bool" sets nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (singleton_iff_center 0
  (singleton_iff_center-1 nil 3530375215
   ("" (skosimp*)
    (("" (prop)
      (("1" (expand* "member" "center")
        (("1" (expand "extend" 1)
          (("1" (skosimp)
            (("1" (case "EXISTS (z:(G!1)): x!1 /= z * x!1 * inv(z)")
              (("1" (skosimp)
                (("1" (decompose-equality -1)
                  (("1" (inst -1 "z!1 * x!1 * inv(z!1)")
                    (("1" (iff)
                      (("1" (prop)
                        (("1" (expand "CL")
                          (("1" (expand "extend")
                            (("1" (prop)
                              (("1"
                                (expand "singleton")
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "extend")
                          (("2" (prop)
                            (("1" (expand "singleton")
                              (("1"
                                (expand "CL")
                                (("1"
                                  (expand "extend")
                                  (("1"
                                    (assert)
                                    (("1" (inst 2 "z!1") nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (typepred "z!1" "x!1")
                                (("2"
                                  (lemma "inv_in")
                                  (("2"
                                    (inst?)
                                    (("2"
                                      (rewrite "product_in")
                                      (("2"
                                        (rewrite "product_in")
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (inst 1 "x!2")
                (("2" (prop)
                  (("2" (hide -2)
                    (("2" (lemma "cancel_right_inv")
                      (("2"
                        (inst -1 "x!1" "x!2 * x!1 * inv(x!2)"
                         "inv(x!2)")
                        (("2" (prop)
                          (("2" (rewrite "inv_inv")
                            (("2" (rewrite "associative")
                              (("2"
                                (rewrite "associative")
                                (("2"
                                  (rewrite "associative")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand* "member" "center")
        (("2" (expand "extend")
          (("2" (decompose-equality 1)
            (("2" (iff)
              (("2" (prop)
                (("1" (expand "singleton")
                  (("1" (expand "CL")
                    (("1" (expand "extend")
                      (("1" (assert)
                        (("1" (skosimp)
                          (("1" (inst -3 "g!1")
                            (("1" (replaces -3)
                              (("1" (rewrite "associative") nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "CL")
                  (("2" (expand "extend") (("2" (assert) nil nil))
                    nil))
                  nil)
                 ("3" (expand "CL")
                  (("3" (expand "extend")
                    (("3" (assert)
                      (("3" (expand "singleton")
                        (("3" (inst 1 "one")
                          (("1" (rewrite "inv_one")
                            (("1" (rewrite "one_left")
                              (("1" (rewrite "one_right") nil nil))
                              nil))
                            nil)
                           ("2" (rewrite "one_in") nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((extend const-decl "R" extend nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (subset? const-decl "bool" sets nil)
    (CL const-decl "{X: set[T] | subset?(X, G)}" normalizer_centralizer
     nil)
    (FALSE const-decl "bool" booleans nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" finite_sets_inductions finite_sets)
    (finite_extend application-judgement "finite_set[T]"
     extend_set_props nil)
    (nonempty_extend application-judgement "(nonempty?[T])"
     extend_set_props nil)
    (inv_in formula-decl nil group nil)
    (product_in formula-decl nil group nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (cancel_right_inv formula-decl nil group nil)
    (associative formula-decl nil semigroup nil)
    (inv_left formula-decl nil group nil)
    (right_identity formula-decl nil monad nil)
    (inv_inv formula-decl nil group nil)
    (member const-decl "bool" sets nil)
    (center const-decl "{s: set[T] | subset?(s, G)}" group nil)
    (G!1 skolem-const-decl "group[T, *, one]" normalizer_centralizer
     nil)
    (one_left formula-decl nil group nil)
    (one_right formula-decl nil group nil)
    (inv_one formula-decl nil group nil)
    (one_in formula-decl nil monad nil)
    (monad? const-decl "bool" monad_def nil)
    (monad nonempty-type-eq-decl nil monad nil)
    (TRUE const-decl "bool" booleans nil)
    (inv_right formula-decl nil group nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil))
   shostak))
 (a_by_c_is_action 0
  (a_by_c_is_action-1 nil 3530281222
   ("" (skosimp*)
    (("" (expand "group_action?")
      (("" (skosimp*)
        (("" (prop)
          (("1" (expand "a_by_c")
            (("1" (rewrite "inv_one")
              (("1" (rewrite "one_left")
                (("1" (rewrite "one_right") nil nil)) nil))
              nil))
            nil)
           ("2" (expand "a_by_c")
            (("2" (rewrite "inv_star")
              (("2" (rewrite "assoc")
                (("2" (rewrite "assoc")
                  (("2" (rewrite "assoc") nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((group_action? const-decl "bool" group_action nil)
    (inv_one formula-decl nil group nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (one_right formula-decl nil group nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (one_left formula-decl nil group nil)
    (a_by_c const-decl "(G)" normalizer_centralizer nil)
    (inv_star formula-decl nil group nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (assoc formula-decl nil group nil))
   shostak))
 (Fix_is_center_TCC1 0
  (Fix_is_center_TCC1-1 nil 3530280384 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (set type-eq-decl nil sets nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subgroup? const-decl "bool" group_def nil))
   nil
   (Fix_is_center subtype "normalizer_centralizer.G"
    "group[normalizer_centralizer.T, normalizer_centralizer.*, normalizer_centralizer.one].subgroup(normalizer_centralizer.G)")))
 (Fix_is_center 0
  (Fix_is_center-1 nil 3530281422
   ("" (skosimp*)
    (("" (decompose-equality 1)
      (("" (iff)
        (("" (prop)
          (("1" (expand* "Fix" "center")
            (("1" (expand "extend")
              (("1" (prop)
                (("1" (expand "a_by_c")
                  (("1" (skosimp)
                    (("1" (inst?)
                      (("1" (hide (-1 -2 -4))
                        (("1" (name-replace "x!3" "x!2 * x!1" :hide? T)
                          (("1" (replace -1 1 rl)
                            (("1" (rewrite "assoc" :dir rl) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand* "Fix" "center")
            (("2" (expand "extend")
              (("2" (prop)
                (("2" (expand "a_by_c")
                  (("2" (skosimp)
                    (("2" (inst?)
                      (("2" (hide (-1 -2 -4))
                        (("2" (replaces -1)
                          (("2" (rewrite "assoc" :dir rl) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (F type-eq-decl nil group_action nil)
    (subset? const-decl "bool" sets nil)
    (Fix const-decl "{Y: set[T1] | subset?(Y, X)}" group_action nil)
    (subgroup? const-decl "bool" group_def nil)
    (subgroup type-eq-decl nil group nil)
    (a_by_c const-decl "(G)" normalizer_centralizer nil)
    (center const-decl "{s: set[T] | subset?(s, G)}" group nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (extend const-decl "R" extend nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (inv_left formula-decl nil group nil)
    (right_identity formula-decl nil monad nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (assoc formula-decl nil group nil)
    (TRUE const-decl "bool" booleans nil)
    (inv_right formula-decl nil group nil))
   shostak))
 (stabilizer_is_centralizer 0
  (stabilizer_is_centralizer-1 nil 3530281854
   ("" (skosimp*)
    (("" (decompose-equality 1)
      (("" (iff)
        (("" (prop)
          (("1" (expand* "stabilizer" "centralizer")
            (("1" (expand "extend")
              (("1" (prop)
                (("1" (expand "a_by_c")
                  (("1" (hide (-1 -2))
                    (("1" (name-replace "x!3" "x!2 * x!1" :hide? T)
                      (("1" (replace -1 1 rl)
                        (("1" (rewrite "assoc" :dir rl) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand* "stabilizer" "centralizer")
            (("2" (expand "extend")
              (("2" (prop)
                (("2" (expand "a_by_c")
                  (("2" (hide (-1 -2))
                    (("2" (replaces -1)
                      (("2" (rewrite "assoc" :dir rl) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (F type-eq-decl nil group_action nil)
    (subset? const-decl "bool" sets nil)
    (stabilizer const-decl "{S: set[T] | subset?(S, G)}" group_action
     nil)
    (subgroup? const-decl "bool" group_def nil)
    (subgroup type-eq-decl nil group nil)
    (a_by_c const-decl "(G)" normalizer_centralizer nil)
    (centralizer const-decl "{S: set[T] | subset?(S, G)}"
     normalizer_centralizer nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (extend const-decl "R" extend nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (inv_left formula-decl nil group nil)
    (right_identity formula-decl nil monad nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (assoc formula-decl nil group nil)
    (TRUE const-decl "bool" booleans nil)
    (inv_right formula-decl nil group nil))
   shostak))
 (orbit_is_CL 0
  (orbit_is_CL-1 nil 3530363031
   ("" (skosimp*)
    (("" (decompose-equality 1)
      (("" (iff) (("" (expand* "orbit" "CL" "a_by_c") nil nil)) nil))
      nil))
    nil)
   ((* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (F type-eq-decl nil group_action nil)
    (subset? const-decl "bool" sets nil)
    (orbit const-decl "{Y: set[T1] | subset?(Y, X)}" group_action nil)
    (subgroup? const-decl "bool" group_def nil)
    (subgroup type-eq-decl nil group nil)
    (a_by_c const-decl "(G)" normalizer_centralizer nil)
    (CL const-decl "{X: set[T] | subset?(X, G)}" normalizer_centralizer
     nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil))
   shostak))
 (orbits_is_CLs 0
  (orbits_is_CLs-1 nil 3530363118
   ("" (skosimp*)
    (("" (decompose-equality 1)
      (("" (iff)
        (("" (expand* "orbits" "orbit" "CLs" "CL" "a_by_c" "extend")
          nil nil))
        nil))
      nil))
    nil)
   ((bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (F type-eq-decl nil group_action nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (orbits const-decl "setofsets[T1]" group_action nil)
    (subgroup? const-decl "bool" group_def nil)
    (subgroup type-eq-decl nil group nil)
    (a_by_c const-decl "(G)" normalizer_centralizer nil)
    (CLs const-decl "setofsets[T]" normalizer_centralizer nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (orbit const-decl "{Y: set[T1] | subset?(Y, X)}" group_action nil)
    (CL const-decl "{X: set[T] | subset?(X, G)}" normalizer_centralizer
     nil))
   shostak))
 (orbits_nFix_is_CLs_nc 0
  (orbits_nFix_is_CLs_nc-1 nil 3530363243
   ("" (skosimp)
    (("" (decompose-equality 1)
      (("" (iff)
        (("" (expand* "orbits_nFix" "CLs_nc")
          (("" (expand "extend")
            (("" (lift-if)
              (("" (lift-if)
                (("" (lift-if)
                  (("" (lemma "Fix_is_center")
                    (("" (inst?)
                      (("" (prop)
                        (("1" (skosimp)
                          (("1" (inst?)
                            (("1" (rewrite "orbit_is_CL") nil nil)
                             ("2" (hide (-2 -3 -4))
                              (("2"
                                (typepred "x!2")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skosimp)
                          (("2" (inst?)
                            (("1" (rewrite "orbit_is_CL") nil nil)
                             ("2" (hide (-2 -3 -4))
                              (("2"
                                (typepred "x!2")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (skosimp)
                          (("3" (hide (-1 -3))
                            (("3" (rewrite "orbits_is_CLs") nil nil))
                            nil))
                          nil)
                         ("4" (skosimp)
                          (("4" (rewrite "orbits_is_CLs") nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (F type-eq-decl nil group_action nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (orbits_nFix const-decl "setofsets[T1]" group_action nil)
    (subgroup? const-decl "bool" group_def nil)
    (subgroup type-eq-decl nil group nil)
    (a_by_c const-decl "(G)" normalizer_centralizer nil)
    (CLs_nc const-decl "setofsets[T]" normalizer_centralizer nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (orbits_is_CLs formula-decl nil normalizer_centralizer nil)
    (x!2 skolem-const-decl "{x: (G!1) | NOT member(x, center(G!1))}"
     normalizer_centralizer nil)
    (orbit_is_CL formula-decl nil normalizer_centralizer nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (center const-decl "{s: set[T] | subset?(s, G)}" group nil)
    (G!1 skolem-const-decl "group[T, *, one]" normalizer_centralizer
     nil)
    (member const-decl "bool" sets nil)
    (Fix const-decl "{Y: set[T1] | subset?(Y, X)}" group_action nil)
    (x!2 skolem-const-decl
     "{x: (G!1) | NOT member(x, Fix(G!1, G!1)(a_by_c(G!1, G!1)))}"
     normalizer_centralizer nil)
    (Fix_is_center formula-decl nil normalizer_centralizer nil)
    (extend const-decl "R" extend nil))
   shostak))
 (CLs_eq_index_TCC1 0
  (CLs_eq_index_TCC1-1 nil 3530354396
   ("" (skosimp)
    (("" (lemma "centralizer_is_subgroup")
      (("" (inst?)
        (("" (assert)
          (("" (lemma "subgroup_is_group")
            (("" (inst?) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((centralizer_is_subgroup formula-decl nil normalizer_centralizer
     nil)
    (subset? const-decl "bool" sets nil)
    (centralizer const-decl "{S: set[T] | subset?(S, G)}"
     normalizer_centralizer nil)
    (subgroup_is_group formula-decl nil group nil)
    (finite_group nonempty-type-eq-decl nil group nil)
    (finite_group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil))
   nil
   (CLs_eq_index subtype
    "normalizer_centralizer.centralizer(normalizer_centralizer.G)(normalizer_centralizer.x)"
    "group[normalizer_centralizer.T, normalizer_centralizer.*, normalizer_centralizer.one].subgroup(normalizer_centralizer.G)")))
 (CLs_eq_index_TCC2 0
  (CLs_eq_index_TCC2-1 nil 3530354396
   ("" (skosimp)
    (("" (lemma "orbit_is_CL")
      (("" (inst?)
        (("" (replace -1 1 rl)
          (("" (hide -1)
            (("" (typepred "G!1")
              (("" (expand "finite_group?")
                (("" (flatten)
                  (("" (hide -1)
                    (("" (rewrite "orbit_is_finite")
                      (("" (hide (-1 2))
                        (("" (rewrite "a_by_c_is_action")
                          (("" (hide 2)
                            (("" (rewrite "group_is_subgroup") nil
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((orbit_is_CL formula-decl nil normalizer_centralizer nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (orbit_is_finite formula-decl nil group_action nil)
    (F type-eq-decl nil group_action nil)
    (subgroup? const-decl "bool" group_def nil)
    (subgroup type-eq-decl nil group nil)
    (a_by_c const-decl "(G)" normalizer_centralizer nil)
    (a_by_c_is_action formula-decl nil normalizer_centralizer nil)
    (group_is_subgroup formula-decl nil group nil)
    (finite_group nonempty-type-eq-decl nil group nil)
    (finite_group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil))
   nil
   (CLs_eq_index subtype
    "normalizer_centralizer.CL(normalizer_centralizer.G)(normalizer_centralizer.x)"
    "finite_set[T]")))
 (CLs_eq_index 0
  (CLs_eq_index-1 nil 3530357482
   ("" (skosimp*)
    (("" (typepred "G!1")
      (("" (expand "finite_group?")
        (("" (flatten)
          (("" (hide -1)
            (("" (lemma "orbits_eq_index")
              (("" (inst -1 "G!1" "G!1" "x!1" "a_by_c(G!1,G!1)")
                (("1" (assert)
                  (("1" (prop)
                    (("1" (rewrite "stabilizer_is_centralizer")
                      (("1" (rewrite "orbit_is_CL") nil nil)) nil)
                     ("2" (hide (-1 2))
                      (("2" (rewrite "a_by_c_is_action")
                        (("2" (hide 2)
                          (("2" (rewrite "group_is_subgroup") nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide (-1 2))
                  (("2" (rewrite "group_is_subgroup") nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_group nonempty-type-eq-decl nil group nil)
    (finite_group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (set type-eq-decl nil sets nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (orbits_eq_index formula-decl nil group_action nil)
    (group_is_subgroup formula-decl nil group nil)
    (a_by_c_is_action formula-decl nil normalizer_centralizer nil)
    (stabilizer_is_centralizer formula-decl nil normalizer_centralizer
     nil)
    (orbit_is_CL formula-decl nil normalizer_centralizer nil)
    (a_by_c const-decl "(G)" normalizer_centralizer nil)
    (subgroup type-eq-decl nil group nil)
    (group nonempty-type-eq-decl nil group nil)
    (F type-eq-decl nil group_action nil)
    (group? const-decl "bool" group_def nil)
    (subgroup? const-decl "bool" group_def nil)
    (G!1 skolem-const-decl "finite_group[T, *, one]"
     normalizer_centralizer nil))
   shostak))
 (class_equation_2_TCC1 0
  (class_equation_2_TCC1-1 nil 3530354396
   ("" (skosimp)
    (("" (lemma "center_subgroup")
      (("" (inst?)
        (("" (expand "subgroup?")
          (("" (typepred "G!1")
            (("" (expand "finite_group?")
              (("" (flatten)
                (("" (hide (-1 -4))
                  (("" (lemma "finite_subset[T]")
                    (("" (inst?) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((one formal-const-decl "T" normalizer_centralizer nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (center_subgroup formula-decl nil group nil)
    (subgroup? const-decl "bool" group_def nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (subset? const-decl "bool" sets nil)
    (center const-decl "{s: set[T] | subset?(s, G)}" group nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (finite_subset formula-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_group nonempty-type-eq-decl nil group nil)
    (finite_group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (class_equation_2 subtype
    "group[normalizer_centralizer.T, normalizer_centralizer.*, normalizer_centralizer.one].center(normalizer_centralizer.G)"
    "finite_set[T]")))
 (class_equation_2_TCC2 0
  (class_equation_2_TCC2-1 nil 3530354396
   ("" (skosimp)
    (("" (case "empty?(CLs_nc(G!1))")
      (("1"
        (case-replace
         "restrict[setof[T], finite_set[T], boolean](CLs_nc(G!1)) = emptyset"
         :hide? T)
        (("1" (rewrite "convergent_empty") nil nil)
         ("2" (hide 2)
          (("2" (decompose-equality 1)
            (("2" (expand "restrict")
              (("2" (expand* "emptyset" "empty?" "member")
                (("2" (inst -2 "x!1") nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "card_partition_TCC2")
        (("2" (inst?)
          (("1" (assert)
            (("1" (hide 3)
              (("1" (expand "nonempty?")
                (("1" (hide 2)
                  (("1" (skosimp)
                    (("1" (typepred "A!1")
                      (("1" (expand "CLs_nc")
                        (("1" (expand "extend")
                          (("1" (prop)
                            (("1" (hide -2)
                              (("1"
                                (expand "CLs")
                                (("1"
                                  (skosimp)
                                  (("1"
                                    (replaces -1)
                                    (("1"
                                      (lemma "orbit_is_CL")
                                      (("1"
                                        (inst?)
                                        (("1"
                                          (replace -1 -2 rl)
                                          (("1"
                                            (hide -1)
                                            (("1"
                                              (lemma "orbit_nonempty")
                                              (("1"
                                                (inst?)
                                                (("1"
                                                  (prop)
                                                  (("1"
                                                    (expand
                                                     "nonempty?")
                                                    (("1"
                                                      (rewrite
                                                       "empty_card")
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide -1)
                                                    (("2"
                                                      (rewrite
                                                       "a_by_c_is_action")
                                                      (("2"
                                                        (hide 2)
                                                        (("2"
                                                          (rewrite
                                                           "group_is_subgroup")
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide (2 3))
            (("2" (lemma "orbits_nFix_is_CLs_nc")
              (("2" (inst?)
                (("2" (replace -1 1 rl)
                  (("2" (hide -1)
                    (("2" (typepred "G!1")
                      (("2" (expand "finite_group?")
                        (("2" (flatten)
                          (("2" (hide -1)
                            (("2" (lemma "orbits_nFix_partition")
                              (("2"
                                (inst?)
                                (("2"
                                  (assert)
                                  (("2"
                                    (hide (-1 2))
                                    (("2"
                                      (rewrite "a_by_c_is_action")
                                      (("2"
                                        (hide 2)
                                        (("2"
                                          (rewrite "group_is_subgroup")
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_group nonempty-type-eq-decl nil group nil)
    (finite_group? const-decl "bool" group_def nil)
    (CLs_nc const-decl "setofsets[T]" normalizer_centralizer nil)
    (setofsets type-eq-decl nil sets nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (empty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (member const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" countable_props
     sets_aux)
    (finite_emptyset name-judgement "finite_set[T]"
     finite_sets_inductions finite_sets)
    (finite_emptyset name-judgement "finite_set" normalizer_centralizer
     nil)
    (convergent_empty formula-decl nil convergence_set sigma_set)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (restrict const-decl "R" restrict nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (G!1 skolem-const-decl "finite_group[T, *, one]"
     normalizer_centralizer nil)
    (finite_partition? const-decl "bool" lagrange_scaf nil)
    (finite_partition type-eq-decl nil lagrange_scaf nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (extend const-decl "R" extend nil)
    (orbit_is_CL formula-decl nil normalizer_centralizer nil)
    (orbit_nonempty formula-decl nil group_action nil)
    (orbit const-decl "{Y: set[T1] | subset?(Y, X)}" group_action nil)
    (subset? const-decl "bool" sets nil)
    (empty_card formula-decl nil finite_sets nil)
    (a_by_c_is_action formula-decl nil normalizer_centralizer nil)
    (group_is_subgroup formula-decl nil group nil)
    (F type-eq-decl nil group_action nil)
    (subgroup? const-decl "bool" group_def nil)
    (subgroup type-eq-decl nil group nil)
    (a_by_c const-decl "(G)" normalizer_centralizer nil)
    (TRUE const-decl "bool" booleans nil)
    (CLs const-decl "setofsets[T]" normalizer_centralizer nil)
    (nonempty? const-decl "bool" sets nil)
    (orbits_nFix_is_CLs_nc formula-decl nil normalizer_centralizer nil)
    (orbits_nFix_partition formula-decl nil group_action nil)
    (card_partition_TCC2 subtype-tcc nil class_equation_scaf nil))
   nil
   (class_equation_2 subtype
    "finite_sets[normalizer_centralizer.T].card"
    "(convergence_set[finite_set[T]].convergent?(restrict[setof[T], finite_set[T], booleans.bool].restrict(normalizer_centralizer.CLs_nc(normalizer_centralizer.G))))")))
 (class_equation_2 0
  (class_equation_2-1 nil 3530354496
   ("" (skosimp*)
    (("" (typepred "G!1")
      (("" (expand "finite_group?")
        (("" (flatten)
          (("" (hide -1)
            (("" (lemma "class_equation")
              (("" (inst -1 "G!1" "G!1" "a_by_c(G!1,G!1)")
                (("1" (assert)
                  (("1" (prop)
                    (("1" (rewrite "Fix_is_center")
                      (("1" (rewrite "orbits_nFix_is_CLs_nc")
                        (("1" (expand "order") (("1" (propax) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide (-1 2))
                      (("2" (expand* "nonempty?" "empty?" "member")
                        (("2" (inst -1 "one")
                          (("2" (rewrite "one_in") nil nil)) nil))
                        nil))
                      nil)
                     ("3" (hide 2)
                      (("3" (lemma "a_by_c_is_action")
                        (("3" (inst -1 "G!1" "G!1")
                          (("3" (assert)
                            (("3" (hide (-1 2))
                              (("3"
                                (rewrite "group_is_subgroup")
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide (-1 2))
                  (("2" (rewrite "group_is_subgroup") nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_group nonempty-type-eq-decl nil group nil)
    (finite_group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" normalizer_centralizer nil)
    (* formal-const-decl "[T, T -> T]" normalizer_centralizer nil)
    (set type-eq-decl nil sets nil)
    (T formal-type-decl nil normalizer_centralizer nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (class_equation formula-decl nil group_action nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (group_is_subgroup formula-decl nil group nil)
    (a_by_c_is_action formula-decl nil normalizer_centralizer nil)
    (one_in formula-decl nil monad nil)
    (monad? const-decl "bool" monad_def nil)
    (monad nonempty-type-eq-decl nil monad nil)
    (nonempty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (Fix_is_center formula-decl nil normalizer_centralizer nil)
    (order const-decl "posnat" monad nil)
    (orbits_nFix_is_CLs_nc formula-decl nil normalizer_centralizer nil)
    (a_by_c const-decl "(G)" normalizer_centralizer nil)
    (subgroup type-eq-decl nil group nil)
    (F type-eq-decl nil group_action nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (subgroup? const-decl "bool" group_def nil)
    (G!1 skolem-const-decl "finite_group[T, *, one]"
     normalizer_centralizer nil))
   shostak)))

