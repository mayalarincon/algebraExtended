%% TCCs associated with theory division_ring
%% This file was automatically generated by PVS, please **do not modify** by hand.
division_ring_TCCS: THEORY BEGIN

	% Assuming TCC generated (at line 25, column 13) for
	% ring_with_one[T, +, *, zero, one]
	% generated from assumption ring_with_one.fullset_is_ring_with_one
	  % proved
	IMP_ring_with_one_TCC1: OBLIGATION
	ring_with_one?[T, +, *, zero, one](fullset[T])
	
	% Assuming TCC generated (at line 25, column 44) for
	% ring_nz_closed[T, +, *, zero]
	% generated from assumption ring_nz_closed.fullset_is_ring_nz_closed
	  % proved
	IMP_ring_nz_closed_TCC1: OBLIGATION
	ring_nz_closed?[T, +, *, zero](fullset[T])
	
	% Existence TCC generated (at line 23, column 3) for
	% IMPORTING group[nz_T[T, +, *, zero], *, one]
	  % proved
	IMP_group_TCC1: OBLIGATION
	EXISTS (x: nz_T[T, +, *, zero]): TRUE
	
	% Subtype TCC generated (at line 26, column 24) for
	% restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T](*)
	% expected type  [[nz_T[T, +, *, zero], nz_T[T, +, *, zero]] ->
	%    nz_T[T, +, *, zero]]
	  % proved
	IMP_group_TCC2: OBLIGATION
	FORALL (x1: [nz_T[T, +, *, zero], nz_T[T, +, *, zero]]): *(x1) /= zero
	
	% Subtype TCC generated (at line 26, column 26) for  one
	% expected type  nz_T[T, +, *, zero]
	  % proved
	IMP_group_TCC3: OBLIGATION
	one /= zero
	
	% Assuming TCC generated (at line 26, column 13) for
	% group[nz_T[T, +, *, zero],
	%       restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	%           (*),
	%       one]
	% generated from assumption group.fullset_is_group
	  % proved
	IMP_group_TCC4: OBLIGATION
	group?
	      [nz_T[T, +, *, zero],
	       restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T](*), one]
	      (fullset[nz_T[T, +, *, zero]])
	
	% Subtype TCC generated (at line 28, column 62) for  fullset[T]
	% expected type  division_ring
	  % proved
	division_ring_TCC1: OBLIGATION
	division_ring?[T, +, *, zero, one](fullset[T])
	
	% The subtype TCC (at line 33, column 31) in decl nil for
	% term generated from recip
	%  inv[nz_T[T, +, *, zero],
	%     restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	%         (*),
	%     one]
	% expected type  [[nz_T[T, +, *, zero], nz_T[T, +, *, zero]] ->
	%    nz_T[T, +, *, zero]]
	% The subtype TCC (at line 33, column 31) in decl nil for
	% term generated from recip
	%  inv[nz_T[T, +, *, zero],
	%     restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	%         (*),
	%     one]
	% expected type  nz_T[T, +, *, zero]
	% The subtype TCC (at line 33, column 31) in decl nil for
	% term generated from /
	%  inv[nz_T[T, +, *, zero],
	%     restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	%         (*),
	%     one]
	% expected type  [[nz_T[T, +, *, zero], nz_T[T, +, *, zero]] ->
	%    nz_T[T, +, *, zero]]
	% The subtype TCC (at line 33, column 31) in decl nil for
	% term generated from /
	%  inv[nz_T[T, +, *, zero],
	%     restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	%         (*),
	%     one]
	% expected type  nz_T[T, +, *, zero]
	% Subtype TCC generated (at line 43, column 38) for  division_ring
	% expected type  ring_with_one
	  % proved
	division_ring_is_ring_with_one: OBLIGATION
	FORALL (x: division_ring): ring_with_one?(x)
	
	% The subtype TCC (at line 33, column 31) in decl nil for
	 % term generated from recip
	    %  inv[nz_T[T, +, *, zero],
	    %     restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	    %         (*),
	    %     one]
	    % expected type  [[nz_T[T, +, *, zero], nz_T[T, +, *, zero]] ->
	                   %    nz_T[T, +, *, zero]]
	  % is subsumed by IMP_group_TCC2
	% The subtype TCC (at line 33, column 31) in decl nil for
	 % term generated from recip
	    %  inv[nz_T[T, +, *, zero],
	    %     restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	    %         (*),
	    %     one]
	    % expected type  nz_T[T, +, *, zero]
	  % is subsumed by IMP_group_TCC3
	% The subtype TCC (at line 33, column 31) in decl nil for
	 % term generated from /
	    %  inv[nz_T[T, +, *, zero],
	    %     restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	    %         (*),
	    %     one]
	    % expected type  [[nz_T[T, +, *, zero], nz_T[T, +, *, zero]] ->
	                   %    nz_T[T, +, *, zero]]
	  % is subsumed by IMP_group_TCC2
	% The subtype TCC (at line 33, column 31) in decl nil for
	 % term generated from /
	    %  inv[nz_T[T, +, *, zero],
	    %     restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	    %         (*),
	    %     one]
	    % expected type  nz_T[T, +, *, zero]
	  % is subsumed by IMP_group_TCC3
	
	% Judgement subtype TCC generated (at line 46, column 38) for  x
	% expected type  ring_nz_closed[T, +, *, zero]
	  % proved
	division_ring_is_ring_nz_closed: OBLIGATION
	FORALL (x: division_ring): ring_nz_closed?[T, +, *, zero](x)
	
	% The subtype TCC (at line 48, column 34) in decl nil for
	% term generated from division_ring_is_group
	%  group?
	%     [nz_T[T, +, *, zero],
	%      restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	%          (*),
	%      one]
	% expected type  [[nz_T[T, +, *, zero], nz_T[T, +, *, zero]] ->
	%    nz_T[T, +, *, zero]]
	% The subtype TCC (at line 48, column 34) in decl nil for
	% term generated from division_ring_is_group
	%  group?
	%     [nz_T[T, +, *, zero],
	%      restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	%          (*),
	%      one]
	% expected type  nz_T[T, +, *, zero]
	% Judgement subtype TCC generated (at line 55, column 38) for
	% n0x *
	%  inv[nz_T[T, +, *, zero],
	%      restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	%          (*),
	%      one]
	%      (n0y)
	%   (generated by making lambda expr n0x *                    inv[nz_T[T, +, *, zero],                        restrict                            [[T, T],                             [nz_T[T, +, *, zero],                              nz_T[T, +, *, zero]],                             T]                            (*),                        one]                        (n0y) from macro division_ring./)
	% expected type  nz_T[T, +, *, zero]
	  % proved
	nz_T_div_nz_T_is_nz_T: OBLIGATION
	FORALL (n0x, n0y):
	    n0x *
	     inv[nz_T[T, +, *, zero],
	         restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T](*),
	         one]
	         (n0y)
	     /= zero
	
	% The subtype TCC (at line 48, column 34) in decl nil for
	 % term generated from division_ring_is_group
	    %  group?
	    %     [nz_T[T, +, *, zero],
	    %      restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	    %          (*),
	    %      one]
	    % expected type  [[nz_T[T, +, *, zero], nz_T[T, +, *, zero]] ->
	                   %    nz_T[T, +, *, zero]]
	  % is subsumed by IMP_group_TCC2
	% The subtype TCC (at line 48, column 34) in decl nil for
	 % term generated from division_ring_is_group
	    %  group?
	    %     [nz_T[T, +, *, zero],
	    %      restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	    %          (*),
	    %      one]
	    % expected type  nz_T[T, +, *, zero]
	  % is subsumed by IMP_group_TCC3
	
	% The subtype TCC (at line 66, column 40) in decl nil for
	% term generated from div_div1
	%  n0y *
	%  inv[nz_T[T, +, *, zero],
	%      restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	%          (*),
	%      one]
	%      (n0z)
	% expected type  nz_T[T, +, *, zero]
	% Subtype TCC generated (at line 67, column 60) for  (n0z * n0y)
	% expected type  nz_T[T, +, *, zero]
	  % proved
	div_div2_TCC1: OBLIGATION
	FORALL (n0y, n0z: nz_T[T, +, *, zero]): (n0z * n0y) /= zero
	
	% The subtype TCC (at line 66, column 40) in decl nil for
	 % term generated from div_div1
	    %  n0y *
	    %  inv[nz_T[T, +, *, zero],
	    %      restrict[[T, T], [nz_T[T, +, *, zero], nz_T[T, +, *, zero]], T]
	    %          (*),
	    %      one]
	    %      (n0z)
	    % expected type  nz_T[T, +, *, zero]
	  % is subsumed by nz_T_div_nz_T_is_nz_T

END division_ring_TCCS