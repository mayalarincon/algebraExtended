(commutative_ring_with_one
 (fullset_is_commutative_ring_with_one 0
  (fullset_is_commutative_ring_with_one-1 nil 3292785972
   ("" (expand "commutative_ring_with_one?")
    (("" (lemma "star_commutative")
      (("" (lemma "fullset_is_ring_with_one") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((fullset_is_ring_with_one formula-decl nil ring_with_one nil)) shostak))
 (IMP_ring_with_one_TCC1 0
  (IMP_ring_with_one_TCC1-1 nil 3292786148
   ("" (lemma "fullset_is_commutative_ring_with_one")
    (("" (expand "commutative_ring_with_one?") (("" (flatten) nil nil)) nil))
    nil)
   ((commutative_ring_with_one? const-decl "bool" ring_with_one_def nil)
    (fullset_is_commutative_ring_with_one formula-decl nil
     commutative_ring_with_one nil))
   shostak
   (IMP_ring_with_one assuming
    "ring_with_one[commutative_ring_with_one.T, commutative_ring_with_one.+, commutative_ring_with_one.*, commutative_ring_with_one.zero, commutative_ring_with_one.one].ring_with_one"
    "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one.T, ring_with_one.+, ring_with_one.*, ring_with_one.zero, ring_with_one.one].ring_with_one?(sets[ring_with_one.T].fullset)")))
 (IMP_commutative_ring_TCC1 0
  (IMP_commutative_ring_TCC1-1 nil 3292786148
   ("" (lemma "fullset_is_commutative_ring_with_one")
    (("" (expand "commutative_ring_with_one?")
      (("" (expand "commutative_ring?")
        (("" (expand "ring_with_one?")
          (("" (flatten) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((commutative_ring_with_one? const-decl "bool" ring_with_one_def nil)
    (ring_with_one? const-decl "bool" ring_with_one_def nil)
    (commutative_ring? const-decl "bool" ring_def nil)
    (fullset_is_commutative_ring_with_one formula-decl nil
     commutative_ring_with_one nil))
   shostak
   (IMP_commutative_ring assuming
    "commutative_ring[commutative_ring_with_one.T, commutative_ring_with_one.+, commutative_ring_with_one.*, commutative_ring_with_one.zero].commutative_ring"
    "fullset_is_commutative_ring: ASSUMPTION ring_def[commutative_ring.T, commutative_ring.+, commutative_ring.*, commutative_ring.zero].commutative_ring?(sets[commutative_ring.T].fullset)")))
 (commutative_ring_with_one_TCC1 0
  (commutative_ring_with_one_TCC1-1 nil 3292786148
   ("" (lemma "fullset_is_commutative_ring_with_one") (("" (propax) nil nil))
    nil)
   ((fullset_is_commutative_ring_with_one formula-decl nil
     commutative_ring_with_one nil))
   shostak
   (commutative_ring_with_one subtype
    "sets[commutative_ring_with_one.T].fullset" "commutative_ring_with_one")))
 (commutative_ring_with_one_is 0
  (commutative_ring_with_one_is-1 nil 3292786031
   ("" (skolem!) (("" (typepred "R!1") (("" (propax) nil nil)) nil)) nil)
   ((commutative_ring_with_one nonempty-type-eq-decl nil
     commutative_ring_with_one nil)
    (commutative_ring_with_one? const-decl "bool" ring_with_one_def nil)
    (one formal-const-decl "T" commutative_ring_with_one nil)
    (zero formal-const-decl "T" commutative_ring_with_one nil)
    (* formal-const-decl "[T, T -> T]" commutative_ring_with_one nil)
    (+ formal-const-decl "[T, T -> T]" commutative_ring_with_one nil)
    (set type-eq-decl nil sets nil)
    (T formal-nonempty-type-decl nil commutative_ring_with_one nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak)))

