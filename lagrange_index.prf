(lagrange_index
 (IMP_right_left_cosets_TCC1 0
  (IMP_right_left_cosets_TCC1-1 nil 3530436270
   ("" (rewrite "fullset_is_group") nil nil)
   ((fullset_is_group formula-decl nil lagrange_index nil)) nil
   (IMP_right_left_cosets assuming
    "right_left_cosets[lagrange_index.T, lagrange_index.*, lagrange_index.one].right_left_cosets"
    "fullset_is_group: ASSUMPTION group_def[right_left_cosets.T, right_left_cosets.*, right_left_cosets.one].group?(sets[right_left_cosets.T].fullset)")))
 (Lagrange_index 0
  (Lagrange_index-1 nil 3528627519
   ("" (skosimp*)
    (("" (expand* "order" "index")
      (("" (lemma "set_left_cosets_full")
        (("" (inst - "G!1" "H!1")
          (("" (lemma "card_eq_part[T]")
            (("" (inst?)
              (("1" (assert)
                (("1" (hide (-1 2))
                  (("1" (prop)
                    (("1" (skosimp)
                      (("1" (typepred "A!1" "B!1")
                        (("1" (expand "left_cosets")
                          (("1" (skosimp*)
                            (("1" (lemma "finite_left_coset_correspondence")
                              (("1" (inst -1 "H!1" "a!1" "a!2" "G!1")
                                (("1" (assert)
                                  (("1" (expand "left_coset")
                                    (("1" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skosimp)
                      (("2" (lemma "left_cosets_disjoint")
                        (("2" (inst - "G!1" "H!1" "A!1" "B!1")
                          (("1" (assert) nil nil)
                           ("2" (typepred "B!1")
                            (("2" (expand "left_cosets")
                              (("2" (propax) nil nil)) nil))
                            nil)
                           ("3" (typepred "A!1")
                            (("3" (expand "left_cosets")
                              (("3" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (expand "left_cosets")
                      (("3" (inst + "one")
                        (("1" (rewrite "left_coset_one") nil nil)
                         ("2" (rewrite "one_in") nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide (-1 2))
                (("2" (lemma "left_cosets_partition") (("2" (inst?) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((index const-decl "nat" right_left_cosets nil)
    (order const-decl "posnat" monad algebra)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (group? const-decl "bool" group_def algebra)
    (group nonempty-type-eq-decl nil group algebra)
    (finite_group? const-decl "bool" group_def algebra)
    (finite_group nonempty-type-eq-decl nil group algebra)
    (subgroup? const-decl "bool" group_def algebra)
    (subgroup type-eq-decl nil group algebra)
    (left_cosets_partition formula-decl nil right_left_cosets nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])"
     sets_lemmas nil)
    (left_coset_one formula-decl nil cosets algebra)
    (one_in formula-decl nil monad algebra)
    (monad? const-decl "bool" monad_def algebra)
    (monad nonempty-type-eq-decl nil monad algebra)
    (left_cosets type-eq-decl nil cosets algebra)
    (B!1 skolem-const-decl "(left_cosets(G!1, H!1))" lagrange_index nil)
    (* const-decl "set[T]" cosets algebra)
    (A!1 skolem-const-decl "(left_cosets(G!1, H!1))" lagrange_index nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (left_cosets_disjoint formula-decl nil right_left_cosets nil)
    (finite_left_coset_correspondence formula-decl nil right_left_cosets nil)
    (member const-decl "bool" sets nil)
    (left_coset const-decl "{s: set[T] | subset?(s, G)}" cosets algebra)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_partition type-eq-decl nil lagrange_scaf algebra)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (finite_partition? const-decl "bool" lagrange_scaf algebra)
    (left_cosets const-decl "setofsets[T]" right_left_cosets nil)
    (G!1 skolem-const-decl "finite_group[T, *, one]" lagrange_index nil)
    (H!1 skolem-const-decl "finite_group[T, *, one]" lagrange_index nil)
    (card_eq_part formula-decl nil lagrange_scaf algebra)
    (set_left_cosets_full formula-decl nil right_left_cosets nil)
    (T formal-nonempty-type-decl nil lagrange_index nil)
    (* formal-const-decl "[T, T -> T]" lagrange_index nil)
    (one formal-const-decl "T" lagrange_index nil))
   shostak))
 (index_divides 0
  (index_divides-1 nil 3530566927
   ("" (skosimp*)
    (("" (expand "divides")
      (("" (lemma "Lagrange_index")
        (("" (inst?) (("" (assert) (("" (inst?) nil nil)) nil)) nil)) nil))
      nil))
    nil)
   ((divides const-decl "bool" divides nil)
    (T formal-nonempty-type-decl nil lagrange_index nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (* formal-const-decl "[T, T -> T]" lagrange_index nil)
    (one formal-const-decl "T" lagrange_index nil)
    (finite_group? const-decl "bool" group_def algebra)
    (finite_group nonempty-type-eq-decl nil group algebra)
    (order const-decl "posnat" monad algebra)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finite_monad nonempty-type-eq-decl nil monad algebra)
    (finite_monad? const-decl "bool" monad_def algebra)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (Lagrange_index formula-decl nil lagrange_index nil))
   shostak))
 (order_factor_TCC1 0
  (order_factor_TCC1-1 nil 3530436270
   ("" (skosimp*) (("" (rewrite "card_factor_TCC1") nil nil)) nil)
   ((card_factor_TCC1 subtype-tcc nil right_left_cosets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (group? const-decl "bool" group_def algebra)
    (group nonempty-type-eq-decl nil group algebra)
    (finite_group? const-decl "bool" group_def algebra)
    (finite_group nonempty-type-eq-decl nil group algebra)
    (T formal-nonempty-type-decl nil lagrange_index nil)
    (* formal-const-decl "[T, T -> T]" lagrange_index nil)
    (one formal-const-decl "T" lagrange_index nil))
   nil
   (order_factor subtype
    "extend[set[T], cosets[lagrange_index.T, lagrange_index.*, lagrange_index.one].left_cosets(lagrange_index.G, lagrange_index.N), booleans.bool, booleans.FALSE].extend(right_left_cosets[lagrange_index.T, lagrange_index.*, lagrange_index.one]./(lagrange_index.G, lagrange_index.N))"
    "finite_set[set[T]]")))
 (order_factor 0
  (order_factor-1 nil 3530436293
   ("" (skosimp*)
    (("" (lemma "card_factor")
      (("" (inst?)
        (("" (assert)
          (("" (replaces -1)
            (("" (lemma "Lagrange_index")
              (("" (inst?)
                (("" (assert)
                  (("" (expand "normal_subgroup?") (("" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((one formal-const-decl "T" lagrange_index nil)
    (* formal-const-decl "[T, T -> T]" lagrange_index nil)
    (T formal-nonempty-type-decl nil lagrange_index nil)
    (card_factor formula-decl nil right_left_cosets nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (Lagrange_index formula-decl nil lagrange_index nil)
    (normal_subgroup? const-decl "boolean" normal_subgroups algebra)
    (TRUE const-decl "bool" booleans nil)
    (finite_group nonempty-type-eq-decl nil group algebra)
    (finite_group? const-decl "bool" group_def algebra)
    (group nonempty-type-eq-decl nil group algebra)
    (group? const-decl "bool" group_def algebra)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak)))

