%% TCCs associated with theory ring_euclidean_algorithm
%% This file was automatically generated by PVS, please **do not modify** by hand.
ring_euclidean_algorithm_TCCS: THEORY BEGIN

	% Assuming TCC generated (at line 33, column 14) for
	% euclidean_domain[T, +, *, zero, one]
	% generated from assumption euclidean_domain.fullset_is_ring_with_one
	  % untried
	IMP_euclidean_domain_TCC1: OBLIGATION
	ring_with_one?[T, +, *, zero, one](fullset[T])
	
	% Subtype TCC generated (at line 48, column 17) for  b
	% expected type  (difference(R, singleton(zero)))
	  % untried
	euclidean_gcd_algorithm_TCC1: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    difference[T](R, singleton[T](zero))(b)
	
	% Subtype TCC generated (at line 48, column 49) for  a
	% expected type  (difference(R, singleton(zero)))
	  % untried
	euclidean_gcd_algorithm_TCC2: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT a = zero IMPLIES difference[T](R, singleton[T](zero))(a)
	
	% Subtype TCC generated (at line 48, column 13) for  z`2
	% expected type  (difference(d1`1, singleton(zero)))
	  % untried
	euclidean_gcd_algorithm_TCC3: OBLIGATION
	FORALL (d1:
	            [R: (euclidean_domain?[T, +, *, zero, one]),
	             phi:
	               {phi: [(difference(R, singleton(zero))) -> nat] |
	                  euclidean_pair?(R, phi)},
	             {f_phi: [(R), (remove(zero, R)) -> [(R), (R)]] |
	                euclidean_f_phi?(R, phi)(f_phi)}],
	          z: [(d1`1), (remove(zero, d1`1))]):
	    difference[T](d1`1, singleton[T](zero))(z`2)
	
	% Subtype TCC generated (at line 48, column 45) for  z`1
	% expected type  (difference(d1`1, singleton(zero)))
	  % untried
	euclidean_gcd_algorithm_TCC4: OBLIGATION
	FORALL (d1:
	            [R: (euclidean_domain?[T, +, *, zero, one]),
	             phi:
	               {phi: [(difference(R, singleton(zero))) -> nat] |
	                  euclidean_pair?(R, phi)},
	             {f_phi: [(R), (remove(zero, R)) -> [(R), (R)]] |
	                euclidean_f_phi?(R, phi)(f_phi)}],
	          z: [(d1`1), (remove(zero, d1`1))]):
	    NOT z`1 = zero IMPLIES difference[T](d1`1, singleton[T](zero))(z`1)
	
	% Subtype TCC generated (at line 48, column 17) for  b
	% expected type  (difference(R, singleton(zero)))
	  % untried
	euclidean_gcd_algorithm_TCC5: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]), b: (remove(zero, R))):
	    difference[T](R, singleton[T](zero))(b)
	
	% Subtype TCC generated (at line 48, column 49) for  a
	% expected type  (difference(R, singleton(zero)))
	  % untried
	euclidean_gcd_algorithm_TCC6: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]), a: (R)):
	    NOT a = zero IMPLIES difference[T](R, singleton[T](zero))(a)
	
	% Subtype TCC generated (at line 44, column 50) for  b
	% expected type  (R)
	  % untried
	euclidean_gcd_algorithm_TCC7: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT a = zero AND phi(a) >= phi(b) IMPLIES
	     FORALL (rem: (R)): rem = (f_phi(a, b))`2 AND NOT rem = zero IMPLIES R(b)
	
	% Subtype TCC generated (at line 44, column 52) for  rem
	% expected type  (remove(zero, R))
	  % untried
	euclidean_gcd_algorithm_TCC8: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT a = zero AND phi(a) >= phi(b) IMPLIES
	     FORALL (rem: (R)):
	       rem = (f_phi(a, b))`2 AND NOT rem = zero IMPLIES remove[T](zero, R)(rem)
	
	% Termination TCC generated (at line 44, column 13) for
	% euclidean_gcd_algorithm(R, phi, f_phi)(b, rem)
	  % untried
	euclidean_gcd_algorithm_TCC9: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT a = zero AND phi(a) >= phi(b) IMPLIES
	     FORALL (rem: (R)):
	       rem = (f_phi(a, b))`2 AND NOT rem = zero IMPLIES
	        lex2(phi(rem), IF b = zero THEN 0 ELSE phi(b) ENDIF) <
	         lex2(phi(b), IF a = zero THEN 0 ELSE phi(a) ENDIF)
	
	% Subtype TCC generated (at line 46, column 45) for  b
	% expected type  (R)
	  % untried
	euclidean_gcd_algorithm_TCC10: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT a = zero AND NOT phi(a) >= phi(b) IMPLIES R(b)
	
	% Subtype TCC generated (at line 46, column 47) for  a
	% expected type  (remove(zero, R))
	  % untried
	euclidean_gcd_algorithm_TCC11: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT a = zero AND NOT phi(a) >= phi(b) IMPLIES remove[T](zero, R)(a)
	
	% Termination TCC generated (at line 46, column 8) for
	% euclidean_gcd_algorithm(R, phi, f_phi)(b, a)
	  % untried
	euclidean_gcd_algorithm_TCC12: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT a = zero AND NOT phi(a) >= phi(b) IMPLIES
	     lex2(phi(a), IF b = zero THEN 0 ELSE phi(b) ENDIF) <
	      lex2(phi(b), IF a = zero THEN 0 ELSE phi(a) ENDIF)
	
	% The subtype TCC (at line 48, column 13) in decl nil for
	% term generated from euclidean_gcd_algorithm  z`2
	% expected type  (difference(d1`1, singleton(zero)))
	% The subtype TCC (at line 48, column 45) in decl nil for
	% term generated from euclidean_gcd_algorithm  z`1
	% expected type  (difference(d1`1, singleton(zero)))
	% The subtype TCC (at line 48, column 17) in decl nil for
	% term generated from euclidean_gcd_algorithm  b
	% expected type  (difference(R, singleton(zero)))
	% The subtype TCC (at line 48, column 49) in decl nil for
	% term generated from euclidean_gcd_algorithm  a
	% expected type  (difference(R, singleton(zero)))
	% The subtype TCC (at line 41, column 13) in decl nil for
	% term generated from euclidean_gcd_algorithm  a
	% expected type  (difference(R, singleton(zero)))
	% The subtype TCC (at line 41, column 23) in decl nil for
	% term generated from euclidean_gcd_algorithm  b
	% expected type  (difference(R, singleton(zero)))
	% Subtype TCC generated (at line 56, column 19) for
	% extend[T, (R), bool, FALSE]({x: (R) | x = a OR x = b})
	% expected type  {X | NOT empty?(X) AND subset?(X, R)}
	  % untried
	Euclid_theorem_TCC1: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R)), g: (remove[T](zero, R))):
	    NOT empty?[T](extend[T, (R), bool, FALSE]({x: (R) | x = a OR x = b})) AND
	     subset?[T](extend[T, (R), bool, FALSE]({x: (R) | x = a OR x = b}), R)
	
	% The subtype TCC (at line 48, column 13) in decl nil for
	 % term generated from euclidean_gcd_algorithm  z`2
	    % expected type  (difference(d1`1, singleton(zero)))
	  % is subsumed by euclidean_gcd_algorithm_TCC3
	% The subtype TCC (at line 48, column 45) in decl nil for
	 % term generated from euclidean_gcd_algorithm  z`1
	    % expected type  (difference(d1`1, singleton(zero)))
	  % is subsumed by euclidean_gcd_algorithm_TCC4
	% The subtype TCC (at line 48, column 17) in decl nil for
	 % term generated from euclidean_gcd_algorithm  b
	    % expected type  (difference(R, singleton(zero)))
	  % is subsumed by euclidean_gcd_algorithm_TCC5
	% The subtype TCC (at line 48, column 49) in decl nil for
	 % term generated from euclidean_gcd_algorithm  a
	    % expected type  (difference(R, singleton(zero)))
	  % is subsumed by euclidean_gcd_algorithm_TCC6
	% The subtype TCC (at line 41, column 13) in decl nil for
	 % term generated from euclidean_gcd_algorithm  a
	    % expected type  (difference(R, singleton(zero)))
	  % is subsumed by euclidean_gcd_algorithm_TCC6
	% The subtype TCC (at line 41, column 23) in decl nil for
	 % term generated from euclidean_gcd_algorithm  b
	    % expected type  (difference(R, singleton(zero)))
	  % is subsumed by euclidean_gcd_algorithm_TCC5
	
	% Subtype TCC generated (at line 57, column 19) for
	% extend[T, (R), bool, FALSE]({x: (R) | x = (f_phi(a, b))`2 OR x = b})
	% expected type  {X | NOT empty?(X) AND subset?(X, R)}
	  % untried
	Euclid_theorem_TCC2: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R)), g: (remove[T](zero, R))):
	    NOT empty?[T]
	            (extend[T, (R), bool, FALSE]
	                 ({x: (R) | x = (f_phi(a, b))`2 OR x = b}))
	     AND
	     subset?[T]
	         (extend[T, (R), bool, FALSE]({x: (R) | x = (f_phi(a, b))`2 OR x = b}),
	          R)
	
	% Subtype TCC generated (at line 65, column 14) for
	% extend[T, (R), bool, FALSE]({x: (R) | x = a OR x = b})
	% expected type  {X | NOT empty?(X) AND subset?(X, R)}
	  % untried
	euclidean_gcd_alg_correctness_TCC1: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT empty?[T](extend[T, (R), bool, FALSE]({x: (R) | x = a OR x = b})) AND
	     subset?[T](extend[T, (R), bool, FALSE]({x: (R) | x = a OR x = b}), R)

END ring_euclidean_algorithm_TCCS

%% TCCs associated with theory ring_euclidean_gcd_algorithm_Z
%% This file was automatically generated by PVS, please **do not modify** by hand.
ring_euclidean_gcd_algorithm_Z_TCCS: THEORY BEGIN

	% Subtype TCC generated (at line 81, column 40) for  fullset[int]
	% expected type  (euclidean_domain?
	%      [int,
	%       restrict
	%           [[numfield, numfield], [int, int], numfield]
	%           (+),
	%       restrict
	%           [[numfield, numfield], [int, int], numfield]
	%           (*),
	%       0, 1])
	  % untried
	Z_TCC1: OBLIGATION
	euclidean_domain?
	      [int, restrict[[numfield, numfield], [int, int], numfield](+),
	       restrict[[numfield, numfield], [int, int], numfield](*), 0, 1]
	      (fullset[int])
	
	% Subtype TCC generated (at line 86, column 24) for  j
	% expected type  posnat
	  % untried
	f_phi_Z_TCC1: OBLIGATION
	FORALL ((j: int | j /= 0)): j > 0 IMPLIES j >= 0
	
	% Subtype TCC generated (at line 86, column 40) for  -j
	% expected type  posnat
	  % untried
	f_phi_Z_TCC2: OBLIGATION
	FORALL ((j: int | j /= 0)): NOT j > 0 IMPLIES -j >= 0 AND -j > 0
	
	% Subtype TCC generated (at line 90, column 67) for  f_phi_Z
	% expected type  [[(Z), (remove(0, Z))] -> [(Z), (Z)]]
	  % untried
	phi_Z_and_f_phi_Z_ok_TCC1: OBLIGATION
	((FORALL (x: int): Z(x)) AND
	    FORALL (x: int): x /= 0 IFF remove[int](0, Z)(x))
	   AND
	   FORALL (x1: [int, {j: int | j /= 0}]): Z(f_phi_Z(x1)`2) AND Z(f_phi_Z(x1)`1)
	
	% Subtype TCC generated (at line 90, column 60) for  phi_Z
	% expected type  {phi: [(difference(Z, singleton(0))) -> nat] |
	%    euclidean_pair?(Z, phi)}
	  % untried
	phi_Z_and_f_phi_Z_ok_TCC2: OBLIGATION
	(FORALL (x: int): x /= 0 IFF difference[int](Z, singleton[int](0))(x)) AND
	   euclidean_pair?
	       [int, restrict[[numfield, numfield], [int, int], numfield](+),
	        restrict[[numfield, numfield], [int, int], numfield](*), 0]
	       (Z, phi_Z)
	
	% Subtype TCC generated (at line 96, column 23) for
	% extend[int, (Z), bool, FALSE]({x: (Z) | x = i OR x = j})
	% expected type  {X | NOT empty?(X) AND subset?(X, Z)}
	  % untried
	euclidean_gcd_alg_correctness_in_Z_TCC1: OBLIGATION
	FORALL (i: int, (j: int | j /= 0)):
	    NOT empty?[int](extend[int, (Z), bool, FALSE]({x: (Z) | x = i OR x = j}))
	     AND
	     subset?[int](extend[int, (Z), bool, FALSE]({x: (Z) | x = i OR x = j}), Z)
	
	% Subtype TCC generated (at line 96, column 106) for  i
	% expected type  (Z)
	  % untried
	euclidean_gcd_alg_correctness_in_Z_TCC2: OBLIGATION
	FORALL (i: int, (j: int | j /= 0)): Z(i)
	
	% Subtype TCC generated (at line 96, column 108) for  j
	% expected type  (remove(0, Z))
	  % untried
	euclidean_gcd_alg_correctness_in_Z_TCC3: OBLIGATION
	FORALL ((j: int | j /= 0)): remove[int](0, Z)(j)
	
	% Subtype TCC generated (at line 96, column 97) for  f_phi_Z
	% expected type  {f_phi: [(Z), (remove(0, Z)) -> [(Z), (Z)]] |
	%    euclidean_f_phi?(Z, phi_Z)(f_phi)}
	  % untried
	euclidean_gcd_alg_correctness_in_Z_TCC4: OBLIGATION
	FORALL ((j: int | j /= 0)):
	    (((FORALL (x: int): Z(x)) AND
	       FORALL (x: int): x /= 0 IFF remove[int](0, Z)(x))
	      AND
	      FORALL (x1: [int, {j: int | j /= 0}]):
	        Z(f_phi_Z(x1)`2) AND Z(f_phi_Z(x1)`1))
	     AND
	     euclidean_f_phi?
	         [int, restrict[[numfield, numfield], [int, int], numfield](+),
	          restrict[[numfield, numfield], [int, int], numfield](*), 0]
	         (Z, phi_Z)(f_phi_Z)
	
	% Assuming TCC generated (at line 96, column 51) for
	% euclidean_gcd_algorithm
	%     [int, restrict[[numfield, numfield], [int, int], numfield](+),
	%      restrict[[numfield, numfield], [int, int], numfield](*), 0, 1]
	% generated from assumption ring_euclidean_algorithm.fullset_is_ring_with_one
	  % untried
	euclidean_gcd_alg_correctness_in_Z_TCC5: OBLIGATION
	FORALL ((j: int | j /= 0)):
	    ring_with_one?
	        [int, restrict[[numfield, numfield], [int, int], numfield](+),
	         restrict[[numfield, numfield], [int, int], numfield](*), 0, 1]
	        (fullset[int])

END ring_euclidean_gcd_algorithm_Z_TCCS

%% TCCs associated with theory ring_euclidean_gcd_algorithm_Zi
%% This file was automatically generated by PVS, please **do not modify** by hand.
ring_euclidean_gcd_algorithm_Zi_TCCS: THEORY BEGIN

	% Subtype TCC generated (at line 131, column 33) for  x * conjugate(x)
	% expected type  real
	  % untried
	sq_abs_Re_Im_integer_rational_pred_TCC1: OBLIGATION
	FORALL (x: (Zi)):
	    rational_pred(Re(x)) AND
	     integer_pred(Re(x)) AND rational_pred(Im(x)) AND integer_pred(Im(x))
	     IMPLIES real_pred(x * conjugate(x))
	
	% The subtype TCC (at line 131, column 68) in decl nil for
	% term generated from sq_abs_Re_Im_integer_rational_pred  x * conjugate(x)
	% expected type  rational
	% Subtype TCC generated (at line 141, column 32) for  x * conjugate(x)
	% expected type  nat
	  % untried
	phi_Zi_TCC1: OBLIGATION
	FORALL (x: (Zi) | x /= 0):
	    real_pred(x * conjugate(x)) AND
	     rational_pred(x * conjugate(x)) AND
	      integer_pred(x * conjugate(x)) AND x * conjugate(x) >= 0
	
	% The subtype TCC (at line 131, column 68) in decl nil for
	 % term generated from sq_abs_Re_Im_integer_rational_pred  x * conjugate(x)
	    % expected type  rational
	  % is subsumed by sq_abs_Re_Im_integer_rational_pred_TCC1
	
	% Subtype TCC generated (at line 146, column 58) for  x * y
	% expected type  {x: (Zi) | x /= 0}
	  % untried
	phi_Zi_is_multiplicative_TCC1: OBLIGATION
	FORALL ((x: (Zi) | x /= 0), (y: (Zi) | y /= 0)): Zi(x * y) AND x * y /= 0
	
	% Subtype TCC generated (at line 156, column 31) for  b
	% expected type  posnat
	  % untried
	div_rem_appx_TCC1: OBLIGATION
	FORALL (a: int, (b: int | b /= 0),
	          r: {r: mod(abs(b)) | EXISTS q: a = r + abs(b) * q}):
	    r = rem(abs(b))(a) AND b > 0 IMPLIES b >= 0
	
	% Subtype TCC generated (at line 156, column 47) for  -b
	% expected type  posnat
	  % untried
	div_rem_appx_TCC2: OBLIGATION
	FORALL (a: int, (b: int | b /= 0),
	          r: {r: mod(abs(b)) | EXISTS q: a = r + abs(b) * q}):
	    r = rem(abs(b))(a) AND NOT b > 0 IMPLIES -b >= 0 AND -b > 0
	
	% Subtype TCC generated (at line 172, column 23) for  Re(y * conjugate(x))
	% expected type  int
	  % untried
	f_phi_Zi_TCC1: OBLIGATION
	FORALL (y: (Zi), (x: (Zi) | x /= 0)):
	    rational_pred(Re(y * conjugate(x))) AND integer_pred(Re(y * conjugate(x)))
	
	% Subtype TCC generated (at line 172, column 45) for  x * conjugate(x)
	% expected type  {b: int | b /= 0}
	  % untried
	f_phi_Zi_TCC2: OBLIGATION
	FORALL (y: (Zi), (x: (Zi) | x /= 0)):
	    real_pred(x * conjugate(x)) AND
	     rational_pred(x * conjugate(x)) AND
	      integer_pred(x * conjugate(x)) AND x * conjugate(x) /= 0
	
	% Subtype TCC generated (at line 172, column 80) for  Im(y * conjugate(x))
	% expected type  int
	  % untried
	f_phi_Zi_TCC3: OBLIGATION
	FORALL (y: (Zi), (x: (Zi) | x /= 0)):
	    rational_pred(Im(y * conjugate(x))) AND integer_pred(Im(y * conjugate(x)))
	
	% Subtype TCC generated (at line 173, column 24) for  q
	% expected type  (Zi)
	  % untried
	f_phi_Zi_TCC4: OBLIGATION
	FORALL (y: (Zi), (x: (Zi) | x /= 0), q: complex, r: complex):
	    q =
	     div_rem_appx(Re(y * conjugate(x)), x * conjugate(x))`1 +
	      div_rem_appx(Im(y * conjugate(x)), x * conjugate(x))`1 * i
	     AND r = y - q * x
	     IMPLIES Zi(q)
	
	% Subtype TCC generated (at line 173, column 26) for  r
	% expected type  (Zi)
	  % untried
	f_phi_Zi_TCC5: OBLIGATION
	FORALL (y: (Zi), (x: (Zi) | x /= 0), q: complex, r: complex):
	    q =
	     div_rem_appx(Re(y * conjugate(x)), x * conjugate(x))`1 +
	      div_rem_appx(Im(y * conjugate(x)), x * conjugate(x))`1 * i
	     AND r = y - q * x
	     IMPLIES Zi(r)
	
	% The subtype TCC (at line 172, column 102) in decl nil for
	% term generated from f_phi_Zi  x * conjugate(x)
	% expected type  {b: int | b /= 0}
	% Subtype TCC generated (at line 177, column 74) for  f_phi_Zi
	% expected type  [[(Zi), (remove(0, Zi))] -> [(Zi), (Zi)]]
	  % untried
	phi_Zi_and_f_phi_Zi_ok_TCC1: OBLIGATION
	FORALL (x2: complex): Zi(x2) AND x2 /= 0 IFF remove[complex](0, Zi)(x2)
	
	% The subtype TCC (at line 172, column 102) in decl nil for
	 % term generated from f_phi_Zi  x * conjugate(x)
	    % expected type  {b: int | b /= 0}
	  % is subsumed by f_phi_Zi_TCC2
	
	% Subtype TCC generated (at line 177, column 63) for  Zi
	% expected type  (euclidean_ring?)
	  % untried
	phi_Zi_and_f_phi_Zi_ok_TCC2: OBLIGATION
	euclidean_ring?
	      [complex,
	       restrict[[numfield, numfield], [complex, complex], numfield](+),
	       restrict[[numfield, numfield], [complex, complex], numfield](*), 0]
	      (Zi)
	
	% Subtype TCC generated (at line 177, column 66) for  phi_Zi
	% expected type  {phi: [(difference(Zi, singleton(0))) -> nat] |
	%    euclidean_pair?(Zi, phi)}
	  % untried
	phi_Zi_and_f_phi_Zi_ok_TCC3: OBLIGATION
	(FORALL (x2: complex):
	     Zi(x2) AND x2 /= 0 IFF difference[complex](Zi, singleton[complex](0))(x2))
	   AND
	   euclidean_pair?
	       [complex,
	        restrict[[numfield, numfield], [complex, complex], numfield](+),
	        restrict[[numfield, numfield], [complex, complex], numfield](*), 0]
	       (Zi, phi_Zi)
	
	% Subtype TCC generated (at line 188, column 30) for
	% extend[complex, (Zi), bool, FALSE]({z: (Zi) | z = x OR z = y})
	% expected type  {X | NOT empty?(X) AND subset?(X, Zi)}
	  % untried
	euclidean_gcd_alg_in_Zi_TCC1: OBLIGATION
	FORALL (x: (Zi), (y: (Zi) | y /= 0)):
	    NOT empty?[complex]
	            (extend[complex, (Zi), bool, FALSE]({z: (Zi) | z = x OR z = y}))
	     AND
	     subset?[complex]
	         (extend[complex, (Zi), bool, FALSE]({z: (Zi) | z = x OR z = y}), Zi)
	
	% Subtype TCC generated (at line 188, column 122) for  y
	% expected type  (remove(0, Zi))
	  % untried
	euclidean_gcd_alg_in_Zi_TCC2: OBLIGATION
	FORALL (x: (Zi), (y: (Zi) | y /= 0)): remove[complex](0, Zi)(y)
	
	% Subtype TCC generated (at line 188, column 99) for  Zi
	% expected type  (euclidean_domain?
	%      [complex,
	%       restrict
	%           [[numfield, numfield], [complex, complex],
	%            numfield]
	%           (+),
	%       restrict
	%           [[numfield, numfield], [complex, complex],
	%            numfield]
	%           (*),
	%       0, 1])
	  % untried
	euclidean_gcd_alg_in_Zi_TCC3: OBLIGATION
	FORALL (x: (Zi), (y: (Zi) | y /= 0)):
	    euclidean_domain?
	        [complex,
	         restrict[[numfield, numfield], [complex, complex], numfield](+),
	         restrict[[numfield, numfield], [complex, complex], numfield](*), 0, 1]
	        (Zi)
	
	% Subtype TCC generated (at line 188, column 110) for  f_phi_Zi
	% expected type  {f_phi: [(Zi), (remove(0, Zi)) -> [(Zi), (Zi)]] |
	%    euclidean_f_phi?(Zi, phi_Zi)(f_phi)}
	  % untried
	euclidean_gcd_alg_in_Zi_TCC4: OBLIGATION
	FORALL (x: (Zi), (y: (Zi) | y /= 0)):
	    (FORALL (x2: complex): Zi(x2) AND x2 /= 0 IFF remove[complex](0, Zi)(x2))
	     AND
	     euclidean_f_phi?
	         [complex,
	          restrict[[numfield, numfield], [complex, complex], numfield](+),
	          restrict[[numfield, numfield], [complex, complex], numfield](*), 0]
	         (Zi, phi_Zi)(f_phi_Zi)
	
	% Assuming TCC generated (at line 188, column 58) for
	% euclidean_gcd_algorithm
	%     [complex,
	%      restrict[[numfield, numfield], [complex, complex], numfield](+),
	%      restrict[[numfield, numfield], [complex, complex], numfield](*),
	%      0, 1]
	% generated from assumption ring_euclidean_algorithm.fullset_is_ring_with_one
	  % untried
	euclidean_gcd_alg_in_Zi_TCC5: OBLIGATION
	FORALL (x: (Zi), (y: (Zi) | y /= 0)):
	    ring_with_one?
	        [complex,
	         restrict[[numfield, numfield], [complex, complex], numfield](+),
	         restrict[[numfield, numfield], [complex, complex], numfield](*), 0, 1]
	        (fullset[complex])
	
	% Subtype TCC generated (at line 188, column 26) for  Zi
	% expected type  (commutative_ring?)
	  % untried
	euclidean_gcd_alg_in_Zi_TCC6: OBLIGATION
	FORALL (x: (Zi), (y: (Zi) | y /= 0)):
	    commutative_ring?
	        [complex,
	         restrict[[numfield, numfield], [complex, complex], numfield](+),
	         restrict[[numfield, numfield], [complex, complex], numfield](*), 0]
	        (Zi)

END ring_euclidean_gcd_algorithm_Zi_TCCS