("ring_nz_closed_def" ring_nz_closed_def nz_closed?_TCC1 0 (nz_closed?_TCC1-1 nil 3294093042 ("" (skosimp) (("" (typepred "x1!1`1") (("" (postpone) nil nil)) nil)) nil) nil shostak))("ring_homomorphisms_def" ring_homomorphisms_def IMP_ring_TCC1 0 (IMP_ring_TCC1-1 nil 3716286944 ("" (lemma "R1_is_ring") (("" (propax) nil nil)) nil) ((R1_is_ring formula-decl nil ring_homomorphisms_def nil)) nil))("ring_homomorphisms_def" ring_homomorphisms_def IMP_ring_TCC2 0 (IMP_ring_TCC2-1 nil 3716286944 ("" (lemma "R2_is_ring") (("" (propax) nil nil)) nil) ((R2_is_ring formula-decl nil ring_homomorphisms_def nil)) nil))("ring_homomorphisms_def" ring_homomorphisms_def IMP_homomorphisms_TCC1 0 (IMP_homomorphisms_TCC1-1 nil 3716286944 ("" (lemma "R1_is_ring") (("" (expand "ring?") (("" (expand "abelian_group?") (("" (assert) nil nil)) nil)) nil)) nil) ((ring? const-decl "bool" ring_def "algebra/") (abelian_group? const-decl "bool" group_def "algebra/") (R1_is_ring formula-decl nil ring_homomorphisms_def nil)) nil))("ring_homomorphisms_def" ring_homomorphisms_def IMP_homomorphisms_TCC2 0 (IMP_homomorphisms_TCC2-1 nil 3716286944 ("" (lemma "R2_is_ring") (("" (expand "ring?") (("" (expand "abelian_group?") (("" (assert) nil nil)) nil)) nil)) nil) ((ring? const-decl "bool" ring_def "algebra/") (abelian_group? const-decl "bool" group_def "algebra/") (R2_is_ring formula-decl nil ring_homomorphisms_def nil)) nil))("ring_homomorphisms_def" ring_homomorphisms_def R_homomorphism?_TCC1 0 (R_homomorphism?_TCC1-1 nil 3709409057 ("" (skosimp) (("" (typepred "R1!1") (("" (expand "ring?") (("" (flatten) (("" (hide-all-but (-1 1)) (("" (expand "abelian_group?") (("" (expand "group?") (("" (expand "monoid?") (("" (expand "monad?") (("" (flatten) (("" (hide-all-but (-1 1)) (("" (expand "star_closed?") (("" (inst -1 "a!1" "b!1") (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ring nonempty-type-eq-decl nil ring "algebra/") (ring? const-decl "bool" ring_def "algebra/") (zero1 formal-const-decl "T1" ring_homomorphisms_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (abelian_group? const-decl "bool" group_def "algebra/") (monoid? const-decl "bool" monoid_def "algebra/") (star_closed? const-decl "bool" groupoid_def "algebra/") (member const-decl "bool" sets nil) (monad? const-decl "bool" monad_def "algebra/") (group? const-decl "bool" group_def "algebra/")) nil))("ring_homomorphisms_def" ring_homomorphisms_def R_homomorphism?_TCC2 0 (R_homomorphism?_TCC2-1 nil 3709409057 ("" (skosimp) (("" (typepred "R1!1") (("" (expand "ring?") (("" (flatten) (("" (hide-all-but (-2 1)) (("" (expand "star_closed?") (("" (inst -1 "a!1" "b!1") (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ring nonempty-type-eq-decl nil ring "algebra/") (ring? const-decl "bool" ring_def "algebra/") (zero1 formal-const-decl "T1" ring_homomorphisms_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (star_closed? const-decl "bool" groupoid_def "algebra/") (member const-decl "bool" sets nil)) nil))("ring_homomorphisms_def" ring_homomorphisms_def R_homo_is_homo 0 (R_homo_is_homo-1 nil 3709409057 ("" (skosimp) (("" (typepred "x!1") (("" (expand "R_homomorphism?") (("" (expand "homomorphism?") (("" (skosimp) (("" (inst -1 "a!1" "b!1") (("" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zero2 formal-const-decl "T2" ring_homomorphisms_def nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphisms_def nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphisms_def nil) (T2 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (ring nonempty-type-eq-decl nil ring "algebra/") (ring? const-decl "bool" ring_def "algebra/") (zero1 formal-const-decl "T1" ring_homomorphisms_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (homomorphism? const-decl "bool" homomorphisms "algebra/")) nil))("ring_homomorphisms_def" ring_homomorphisms_def zero_to_zero_TCC1 0 (zero_to_zero_TCC1-1 nil 3715688144 ("" (skosimp) (("" (typepred "R1!1") (("" (expand "ring?") (("" (expand "abelian_group?") (("" (expand "group?") (("" (expand "monoid?") (("" (expand "monad?") (("" (flatten) (("" (hide-all-but (-2 1)) (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ring nonempty-type-eq-decl nil ring "algebra/") (ring? const-decl "bool" ring_def "algebra/") (zero1 formal-const-decl "T1" ring_homomorphisms_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (abelian_group? const-decl "bool" group_def "algebra/") (monoid? const-decl "bool" monoid_def "algebra/") (member const-decl "bool" sets nil) (monad? const-decl "bool" monad_def "algebra/") (group? const-decl "bool" group_def "algebra/")) nil))("ring_homomorphisms_def" ring_homomorphisms_def zero_to_zero 0 (zero_to_zero-1 nil 3715688344 ("" (skosimp) (("" (lemma "homo_one") (("" (inst -1 "R1!1" "R2!1" "phi!1") (("" (lemma "R_homo_is_homo") (("" (inst -1 "R1!1" "R2!1" "phi!1") nil nil)) nil)) nil)) nil)) nil) ((zero2 formal-const-decl "T2" ring_homomorphisms_def nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphisms_def nil) (T2 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (zero1 formal-const-decl "T1" ring_homomorphisms_def nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (T1 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (homo_one formula-decl nil homomorphisms "algebra/") (R_homo_is_homo judgement-tcc nil ring_homomorphisms_def nil) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphisms_def nil) (R2!1 skolem-const-decl "ring[T2, s2, p2, zero2]" ring_homomorphisms_def nil) (phi!1 skolem-const-decl "R_homomorphism(R1!1, R2!1)" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (homomorphism type-eq-decl nil homomorphisms "algebra/") (homomorphism? const-decl "bool" homomorphisms "algebra/") (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphisms_def nil) (ring nonempty-type-eq-decl nil ring "algebra/") (ring? const-decl "bool" ring_def "algebra/") (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (group nonempty-type-eq-decl nil group "algebra/") (group? const-decl "bool" group_def "algebra/") (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak))("ring_homomorphisms_def" ring_homomorphisms_def inv1_to_inv2_homo_TCC1 0 (inv1_to_inv2_homo_TCC1-1 nil 3709409057 ("" (skosimp) (("" (typepred "R1!1") (("" (expand "ring?") (("" (expand "abelian_group?") (("" (expand "group?") (("" (flatten) (("" (hide-all-but (-2 1)) (("" (typepred "x!1") (("" (expand "inv_exists?") (("" (inst -2 "x!1") (("" (skosimp) (("" (hide -3) (("" (typepred "inv(x!1)") (("" (hide -2) (("" (replace -1 -3 rl) (("" (hide -1) (("" (rewrite "cancel_left_plus") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ring nonempty-type-eq-decl nil ring "algebra/") (ring? const-decl "bool" ring_def "algebra/") (zero1 formal-const-decl "T1" ring_homomorphisms_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (abelian_group? const-decl "bool" group_def "algebra/") (cancel_left_plus formula-decl nil ring "algebra/") (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (inv const-decl "{y | x * y = one AND y * x = one}" group "algebra/") (inv_exists? const-decl "bool" group_def "algebra/") (group? const-decl "bool" group_def "algebra/")) nil))("ring_homomorphisms_def" ring_homomorphisms_def inv1_to_inv2_homo 0 (inv1_to_inv2_homo-1 nil 3709410310 ("" (skosimp) (("" (skosimp) (("" (typepred "phi!1") (("" (expand "R_homomorphism?") (("" (inst -1 "x!1" "inv(x!1)") (("" (flatten) (("" (hide -2) (("" (assert) (("" (rewrite "zero_to_zero") (("" (lemma "plus_zero[T2,s2,p2,zero2]") (("" (inst -1 "inv(phi!1(x!1))") (("" (replace -2 -1) (("" (hide -2) (("" (rewrite "plus_associative" -1 :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inv_right formula-decl nil group "algebra/") (plus_zero formula-decl nil ring "algebra/") (left_identity formula-decl nil monad "algebra/") (inv_left formula-decl nil group "algebra/") (plus_associative formula-decl nil ring "algebra/") (zero_to_zero formula-decl nil ring_homomorphisms_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (inv const-decl "{y | x * y = one AND y * x = one}" group "algebra/") (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (set type-eq-decl nil sets nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (zero1 formal-const-decl "T1" ring_homomorphisms_def nil) (ring? const-decl "bool" ring_def "algebra/") (ring nonempty-type-eq-decl nil ring "algebra/") (T2 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphisms_def nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphisms_def nil) (zero2 formal-const-decl "T2" ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil)) shostak))("division_ring_def" division_ring_def division_ring?_TCC1 0 (division_ring?_TCC1-1 nil 3293998727 ("" (skosimp*) (("" (typepred "x1!1`1") (("" (typepred "x1!1`2") (("" (postpone) nil nil)) nil)) nil)) nil) nil shostak))("division_ring_def" division_ring_def division_ring?_TCC2 0 (division_ring?_TCC2-1 nil 3293998727 ("" (postpone) nil nil) nil shostak))("division_ring_def" division_ring_def division_ring?_TCC3 0 (division_ring?_TCC3-1 nil 3293998727 ("" (postpone) nil nil) nil shostak))("finite_integral_domain" finite_integral_domain nzx_member_S_TCC1 0 (nzx_member_S_TCC1-1 nil 3711982167 ("" (skosimp) (("" (typepred "S!1") (("" (expand "finite_integral_domain?") (("" (assert) nil nil)) nil)) nil)) nil) ((finite_integral_domain? const-decl "bool" finite_integral_domain nil) (set type-eq-decl nil sets nil) (T formal-nonempty-type-decl nil finite_integral_domain nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("ring_with_one_homomorphism" ring_with_one_homomorphism ring_w_one_isomorphic_groupoid 0 (ring_w_one_isomorphic_groupoid-1 nil 3853327936 ("" (skosimp) (("" (lemma "bijective_inverse_exists[(R!1),(S!1)]") (("" (skosimp) (("" (case "bijective?[(R!1), (S!1)](phi!1)") (("1" (inst -2 "phi!1") (("1" (expand "exists1") (("1" (flatten) (("1" (skosimp) (("1" (inst 1 "x!1(zero2)" "x!1(one2)") (("1" (expand "ring_with_one?") (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("ring_general_results" ring_general_results_extras teste 0 (teste-1 nil 3813595903 ("" (skeep) (("" (postpone) nil nil)) nil) nil shostak))("ring_principal_ideal" ring_principal_ideal convergent_chain 0 (convergent_chain-1 nil 3853575777 ("" (skosimp*) (("" (lemma "ideal_iunion_ideal") (("" (inst -1 "R!1" "seq!1") (("" (split) (("1" (typepred "R!1") (("1" (expand "principal_ideal_ring?") (("1" (flatten) (("1" (inst -2 "IUnion(seq!1)") (("1" (assert) (("1" (skeep) (("1" (lemma "gen_is_member") (("1" (inst -1 "R!1" "a") (("1" (expand "member") (("1" (replace -3 -1 rl) (("1" (expand "IUnion" -1) (("1" (skeep) (("1" (inst 1 "i") (("1" (skeep) (("1" (typepred "k") (("1" (decompose-equality 1) (("1" (iff) (("1" (prop) (("1" (lemma "principal_ideal_subset") (("1" (inst -1 "R!1" "a" "seq!1(i)") (("1" (assert) (("1" (case "subset?(seq!1(k), IUnion(seq!1))") (("1" (expand "subset?" -1) (("1" (inst -1 "x!1") (("1" (expand "member") (("1" (replace -7 -2 rl) (("1" (expand "subset?" -2) (("1" (inst -2 "x!1") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?") (("2" (skeep) (("2" (expand "member") (("2" (hide-all-but (-1 1)) (("2" (expand "IUnion") (("2" (inst 1 "k") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -7 "i") nil nil)) nil)) nil) ("2" (inst -8 "i" "k") (("2" (assert) (("2" (expand "subset?") (("2" (inst -8 "x!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_principal_ideal nil) (* formal-const-decl "[T, T -> T]" ring_principal_ideal nil) (+ formal-const-decl "[T, T -> T]" ring_principal_ideal nil) (T formal-nonempty-type-decl nil ring_principal_ideal nil) (ideal_iunion_ideal formula-decl nil ring_ideal nil) (IUnion const-decl "set[T]" indexed_sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) nil nil nil (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (subset? const-decl "bool" sets nil) (principal_ideal_subset formula-decl nil ring_principal_ideal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (gen_is_member formula-decl nil ring_principal_ideal nil) (NOT const-decl "[bool -> bool]" booleans nil) (sequence type-eq-decl nil sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (principal_ideal_ring type-eq-decl nil ring_principal_ideal_def nil) (principal_ideal_ring? const-decl "bool" ring_principal_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_TCC1 0 (power_TCC1-1 nil 3292925562 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans) (bool nonempty-type-eq-decl nil booleans) (NOT const-decl "[bool -> bool]" booleans) (number nonempty-type-decl nil numbers) (number_field_pred const-decl "[number -> boolean]" number_fields) (number_field nonempty-type-from-decl nil number_fields) (real_pred const-decl "[number_field -> boolean]" reals) (real nonempty-type-from-decl nil reals) (>= const-decl "bool" reals) (rational_pred const-decl "[real -> boolean]" rationals) (rational nonempty-type-from-decl nil rationals) (integer_pred const-decl "[rational -> boolean]" integers) (int nonempty-type-eq-decl nil integers) (nat nonempty-type-eq-decl nil naturalnumbers)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_TCC2 0 (power_TCC2-1 nil 3292925568 ("" (grind) nil nil) nil shostak))("cyclic_monoid_def" cyclic_monoid_def power_0 0 (power_0-1 nil 3292925609 ("" (grind) nil nil) ((power def-decl "T" groups)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_1 0 (power_1-1 nil 3292925615 ("" (grind) nil nil) ((power def-decl "T" groups) (one formal-const-decl "T" groups) (* formal-const-decl "[T, T -> T]" groups) (T formal-nonempty-type-decl nil groups) (right_identity formula-decl nil monoids)) shostak))("cyclic_monoid_def" cyclic_monoid_def one_power 0 (one_power-1 nil 3292925621 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "power" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ((* formal-const-decl "[T, T -> T]" groups) (left_identity formula-decl nil monoids) (nat_induction formula-decl nil naturalnumbers) (one formal-const-decl "T" groups) (power def-decl "T" groups) (= const-decl "[T, T -> boolean]" equalities) (T formal-nonempty-type-decl nil groups) (pred type-eq-decl nil defined_types) (nat nonempty-type-eq-decl nil naturalnumbers) (>= const-decl "bool" reals) (bool nonempty-type-eq-decl nil booleans) (int nonempty-type-eq-decl nil integers) (integer_pred const-decl "[rational -> boolean]" integers) (rational nonempty-type-from-decl nil rationals) (rational_pred const-decl "[real -> boolean]" rationals) (real nonempty-type-from-decl nil reals) (real_pred const-decl "[number_field -> boolean]" reals) (number_field nonempty-type-from-decl nil number_fields) (number_field_pred const-decl "[number -> boolean]" number_fields) (boolean nonempty-type-decl nil booleans) (number nonempty-type-decl nil numbers)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_def 0 (power_def-1 nil 3292925779 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (inst - "a!1") (("2" (expand "power" 1) (("2" (lemma "cancel_left" ("z" "a!1" "x" "power(a!1, j!1 + 1)" "y" "power(a!1, j!1) * a!1")) (("2" (rewrite "associative") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((associative formula-decl nil monoids) (cancel_left formula-decl nil groups) (one formal-const-decl "T" groups) (right_identity formula-decl nil monoids) (left_identity formula-decl nil monoids) (nat_induction formula-decl nil naturalnumbers) (* formal-const-decl "[T, T -> T]" groups) (+ const-decl "[numfield, numfield -> numfield]" number_fields) (numfield nonempty-type-eq-decl nil number_fields) (power def-decl "T" groups) (= const-decl "[T, T -> boolean]" equalities) (T formal-nonempty-type-decl nil groups) (pred type-eq-decl nil defined_types) (nat nonempty-type-eq-decl nil naturalnumbers) (>= const-decl "bool" reals) (bool nonempty-type-eq-decl nil booleans) (int nonempty-type-eq-decl nil integers) (integer_pred const-decl "[rational -> boolean]" integers) (rational nonempty-type-from-decl nil rationals) (rational_pred const-decl "[real -> boolean]" rationals) (real nonempty-type-from-decl nil reals) (real_pred const-decl "[number_field -> boolean]" reals) (number_field nonempty-type-from-decl nil number_fields) (number_field_pred const-decl "[number -> boolean]" number_fields) (boolean nonempty-type-decl nil booleans) (number nonempty-type-decl nil numbers)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_mult 0 (power_mult-1 nil 3292925654 ("" (induct "m") (("1" (skolem!) (("1" (rewrite "power_0") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "a!1" "n!1+1") (("2" (rewrite "power_def" -1) (("2" (expand "power" 1 2) (("2" (rewrite "associative" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((power_def formula-decl nil groups) (associative formula-decl nil monoids) (one formal-const-decl "T" groups) (right_identity formula-decl nil monoids) (power_0 formula-decl nil groups) (nat_induction formula-decl nil naturalnumbers) (+ const-decl "[numfield, numfield -> numfield]" number_fields) (numfield nonempty-type-eq-decl nil number_fields) (power def-decl "T" groups) (* formal-const-decl "[T, T -> T]" groups) (= const-decl "[T, T -> boolean]" equalities) (T formal-nonempty-type-decl nil groups) (pred type-eq-decl nil defined_types) (nat nonempty-type-eq-decl nil naturalnumbers) (>= const-decl "bool" reals) (bool nonempty-type-eq-decl nil booleans) (int nonempty-type-eq-decl nil integers) (integer_pred const-decl "[rational -> boolean]" integers) (rational nonempty-type-from-decl nil rationals) (rational_pred const-decl "[real -> boolean]" rationals) (real nonempty-type-from-decl nil reals) (real_pred const-decl "[number_field -> boolean]" reals) (number_field nonempty-type-from-decl nil number_fields) (number_field_pred const-decl "[number -> boolean]" number_fields) (boolean nonempty-type-decl nil booleans) (number nonempty-type-decl nil numbers)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_power 0 (power_power-1 nil 3292926190 ("" (induct "m") (("1" (skolem!) (("1" (rewrite "power_0") (("1" (rewrite "power_0") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "power" 1 1) (("2" (inst - "a!1" "n!1") (("2" (replace -1) (("2" (rewrite "power_mult") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((power_mult formula-decl nil groups) (power_0 formula-decl nil groups) (nat_induction formula-decl nil naturalnumbers) (* const-decl "[numfield, numfield -> numfield]" number_fields) (numfield nonempty-type-eq-decl nil number_fields) (power def-decl "T" groups) (= const-decl "[T, T -> boolean]" equalities) (T formal-nonempty-type-decl nil groups) (pred type-eq-decl nil defined_types) (nat nonempty-type-eq-decl nil naturalnumbers) (>= const-decl "bool" reals) (bool nonempty-type-eq-decl nil booleans) (int nonempty-type-eq-decl nil integers) (integer_pred const-decl "[rational -> boolean]" integers) (rational nonempty-type-from-decl nil rationals) (rational_pred const-decl "[real -> boolean]" rationals) (real nonempty-type-from-decl nil reals) (real_pred const-decl "[number_field -> boolean]" reals) (number_field nonempty-type-from-decl nil number_fields) (number_field_pred const-decl "[number -> boolean]" number_fields) (boolean nonempty-type-decl nil booleans) (number nonempty-type-decl nil numbers)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_commutes 0 (power_commutes-1 nil 3292926297 ("" (skolem!) (("" (rewrite "power_mult") (("" (rewrite "power_mult") nil nil)) nil)) nil) ((power_mult formula-decl nil groups) (T formal-nonempty-type-decl nil groups) (number nonempty-type-decl nil numbers) (boolean nonempty-type-decl nil booleans) (number_field_pred const-decl "[number -> boolean]" number_fields) (number_field nonempty-type-from-decl nil number_fields) (real_pred const-decl "[number_field -> boolean]" reals) (real nonempty-type-from-decl nil reals) (rational_pred const-decl "[real -> boolean]" rationals) (rational nonempty-type-from-decl nil rationals) (integer_pred const-decl "[rational -> boolean]" integers) (int nonempty-type-eq-decl nil integers) (bool nonempty-type-eq-decl nil booleans) (>= const-decl "bool" reals) (nat nonempty-type-eq-decl nil naturalnumbers)) shostak))("cyclic_monoid_def" cyclic_monoid_def inv_power 0 (inv_power-1 nil 3292926316 ("" (induct "m") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "power" 1 1) (("2" (rewrite "inv_star") (("2" (rewrite "power_def") (("2" (inst - "a!1") (("2" (lemma "cancel_right" ("z" "inv(a!1)" "x" "inv(power(a!1, j!1))" "y" "power(inv(a!1), j!1)")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inv_star formula-decl nil groups) (cancel_right formula-decl nil groups) (+ const-decl "[numfield, numfield -> numfield]" number_fields) (- const-decl "[numfield, numfield -> numfield]" number_fields) (numfield nonempty-type-eq-decl nil number_fields) (power_def formula-decl nil groups) (inv_one formula-decl nil groups) (nat_induction formula-decl nil naturalnumbers) (power def-decl "T" groups) (inv const-decl "{y | x * y = one AND y * x = one}" groups) (one formal-const-decl "T" groups) (* formal-const-decl "[T, T -> T]" groups) (AND const-decl "[bool, bool -> bool]" booleans) (= const-decl "[T, T -> boolean]" equalities) (T formal-nonempty-type-decl nil groups) (pred type-eq-decl nil defined_types) (nat nonempty-type-eq-decl nil naturalnumbers) (>= const-decl "bool" reals) (bool nonempty-type-eq-decl nil booleans) (int nonempty-type-eq-decl nil integers) (integer_pred const-decl "[rational -> boolean]" integers) (rational nonempty-type-from-decl nil rationals) (rational_pred const-decl "[real -> boolean]" rationals) (real nonempty-type-from-decl nil reals) (real_pred const-decl "[number_field -> boolean]" reals) (number_field nonempty-type-from-decl nil number_fields) (number_field_pred const-decl "[number -> boolean]" number_fields) (boolean nonempty-type-decl nil booleans) (number nonempty-type-decl nil numbers)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_inv_right 0 (power_inv_right-1 nil 3292926510 ("" (skolem!) (("" (rewrite "inv_power" :dir rl) (("" (assert) nil nil)) nil)) nil) ((inv_power formula-decl nil groups) (T formal-nonempty-type-decl nil groups) (number nonempty-type-decl nil numbers) (boolean nonempty-type-decl nil booleans) (number_field_pred const-decl "[number -> boolean]" number_fields) (number_field nonempty-type-from-decl nil number_fields) (real_pred const-decl "[number_field -> boolean]" reals) (real nonempty-type-from-decl nil reals) (rational_pred const-decl "[real -> boolean]" rationals) (rational nonempty-type-from-decl nil rationals) (integer_pred const-decl "[rational -> boolean]" integers) (int nonempty-type-eq-decl nil integers) (bool nonempty-type-eq-decl nil booleans) (>= const-decl "bool" reals) (nat nonempty-type-eq-decl nil naturalnumbers) (inv_right formula-decl nil groups)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_inv_left 0 (power_inv_left-1 nil 3292926554 ("" (skolem!) (("" (rewrite "inv_power" :dir rl) (("" (assert) nil nil)) nil)) nil) ((inv_power formula-decl nil groups) (T formal-nonempty-type-decl nil groups) (number nonempty-type-decl nil numbers) (boolean nonempty-type-decl nil booleans) (number_field_pred const-decl "[number -> boolean]" number_fields) (number_field nonempty-type-from-decl nil number_fields) (real_pred const-decl "[number_field -> boolean]" reals) (real nonempty-type-from-decl nil reals) (rational_pred const-decl "[real -> boolean]" rationals) (rational nonempty-type-from-decl nil rationals) (integer_pred const-decl "[rational -> boolean]" integers) (int nonempty-type-eq-decl nil integers) (bool nonempty-type-eq-decl nil booleans) (>= const-decl "bool" reals) (nat nonempty-type-eq-decl nil naturalnumbers) (inv_left formula-decl nil groups)) shostak))("cyclic_monoid_def" cyclic_monoid_def cyclic_group_is_abelian 0 (cyclic_group_is_abelian-1 nil 3293272131 ("" (skolem 1 ("G!1")) (("" (typepred "G!1") (("" (expand "cyclic_group?") (("" (flatten) (("" (expand "abelian_group?") (("" (assert) (("" (expand "cyclic?") (("" (skolem!) (("" (replace -1 -2) (("" (expand "commutative_over?") (("" (skosimp*) (("" (replace -1) (("" (assert) (("" (expand "generated_by") (("" (skosimp*) (("" (lemma "expt_mult" ("a" "a!1" "i" "i!1" "j" "i!2")) (("" (lemma "expt_mult" ("a" "a!1" "i" "i!2" "j" "i!1")) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cyclic_group nonempty-type-eq-decl nil groups) (cyclic_group? const-decl "bool" groups) (set type-eq-decl nil sets) (T formal-nonempty-type-decl nil groups) (NOT const-decl "[bool -> bool]" booleans) (bool nonempty-type-eq-decl nil booleans) (boolean nonempty-type-decl nil booleans) (commutative_over? const-decl "bool" operator_defs_more) (generated_by const-decl "group" groups) (int nonempty-type-eq-decl nil integers) (integer_pred const-decl "[rational -> boolean]" integers) (rational nonempty-type-from-decl nil rationals) (rational_pred const-decl "[real -> boolean]" rationals) (real nonempty-type-from-decl nil reals) (real_pred const-decl "[number_field -> boolean]" reals) (number_field nonempty-type-from-decl nil number_fields) (number_field_pred const-decl "[number -> boolean]" number_fields) (number nonempty-type-decl nil numbers) (expt_mult formula-decl nil groups) (member const-decl "bool" sets) (cyclic? const-decl "bool" groups) (abelian_group? const-decl "bool" groups_def)) shostak))("groups_scaf" groups_scaf IMP_finite_groups_TCC1 0 (IMP_finite_groups_TCC1-1 nil 3861917862 ("" (lemma "fullset_is_group") (("" (propax) nil nil)) nil) ((fullset_is_group formula-decl nil groups_scaf nil)) nil (IMP_finite_groups assuming "finite_groups[groups_scaf.T, groups_scaf.*, groups_scaf.one].finite_groups" "fullset_is_group: ASSUMPTION group_def[finite_groups.T, finite_groups.*, finite_groups.one].group?(sets[finite_groups.T].fullset)")))("products_subgroups" products_subgroups IMP_normal_subgroups_TCC1 0 (IMP_normal_subgroups_TCC1-1 nil 3529777527 ("" (rewrite "fullset_is_group") nil nil) ((fullset_is_group formula-decl nil products_subgroups nil)) nil (IMP_normal_subgroups assuming "algebra@normal_subgroups[products_subgroups.T, products_subgroups.*, products_subgroups.one].normal_subgroups" "fullset_is_group: ASSUMPTION group_def[normal_subgroups.T, normal_subgroups.*, normal_subgroups.one].group?(sets[normal_subgroups.T].fullset)")))("group_action" group_action IMP_lagrange_index_TCC1 0 (IMP_lagrange_index_TCC1-1 nil 3799510538 ("" (rewrite "fullset_is_group") nil nil) ((fullset_is_group formula-decl nil group_action nil)) nil (IMP_lagrange_index assuming "lagrange_index[group_action.T, group_action.*, group_action.one].lagrange_index" "fullset_is_group: ASSUMPTION group_def[lagrange_index.T, lagrange_index.*, lagrange_index.one].group?(sets[lagrange_index.T].fullset)")))("normalizer_centralizer" normalizer_centralizer IMP_group_action_TCC1 0 (IMP_group_action_TCC1-1 nil 3799515121 ("" (rewrite "fullset_is_group") nil nil) ((fullset_is_group formula-decl nil normalizer_centralizer nil)) nil (IMP_group_action assuming "group_action[normalizer_centralizer.T, normalizer_centralizer.*, normalizer_centralizer.one, normalizer_centralizer.T].group_action" "fullset_is_group: ASSUMPTION group_def[group_action.T, group_action.*, group_action.one].group?(sets[group_action.T].fullset)")))("cauchy" cauchy IMP_finite_cyclic_groups_TCC1 0 (IMP_finite_cyclic_groups_TCC1-1 nil 3531317209 ("" (rewrite "fullset_is_group") nil nil) ((fullset_is_group formula-decl nil cauchy nil)) nil (IMP_finite_cyclic_groups assuming "finite_cyclic_groups[cauchy.T, cauchy.*, cauchy.one].finite_cyclic_groups" "fullset_is_group: ASSUMPTION group_def[finite_cyclic_groups.T, finite_cyclic_groups.*, finite_cyclic_groups.one].group?(sets[finite_cyclic_groups.T].fullset)")))("p_groups" p_groups IMP_finite_groups_TCC1 0 (IMP_finite_groups_TCC1-1 nil 3530721851 ("" (rewrite "fullset_is_group") nil nil) ((fullset_is_group formula-decl nil p_groups nil)) nil (IMP_finite_groups assuming "finite_groups[p_groups.T, p_groups.*, p_groups.one].finite_groups" "fullset_is_group: ASSUMPTION group_def[finite_groups.T, finite_groups.*, finite_groups.one].group?(sets[finite_groups.T].fullset)")))("sylow_theorems" sylow_theorems IMP_finite_groups_TCC1 0 (IMP_finite_groups_TCC1-1 nil 3807089562 ("" (rewrite "T_is_group") nil nil) ((T_is_group formula-decl nil sylow_theorems nil)) nil (IMP_finite_groups assuming "finite_groups[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one].finite_groups" "fullset_is_group: ASSUMPTION group_def[finite_groups.T, finite_groups.*, finite_groups.one].group?(sets[finite_groups.T].fullset)")))("ring_ideal" ring_ideal IMP_ring_basic_properties_TCC1 0 (IMP_ring_basic_properties_TCC1-1 nil 3846255750 ("" (lemma "fullset_is_ring") (("" (propax) nil nil)) nil) ((fullset_is_ring formula-decl nil ring_ideal nil)) nil (IMP_ring_basic_properties assuming "ring_basic_properties[ring_ideal.T, ring_ideal.+, ring_ideal.*, ring_ideal.zero].ring_basic_properties" "fullset_is_ring: ASSUMPTION ring_def[ring_basic_properties.T, ring_basic_properties.+, ring_basic_properties.*, ring_basic_properties.zero].ring?(sets[ring_basic_properties.T].fullset)")))("quotient_rings" quotient_rings IMP_ring_cosets_lemmas_TCC1 0 (IMP_ring_cosets_lemmas_TCC1-1 nil 3793737437 ("" (rewrite "fullset_is_ring") nil nil) ((fullset_is_ring formula-decl nil quotient_rings nil)) nil (IMP_ring_cosets_lemmas assuming "ring_cosets_lemmas[quotient_rings.T, quotient_rings.+, quotient_rings.*, quotient_rings.zero].ring_cosets_lemmas" "fullset_is_ring: ASSUMPTION ring_def[ring_cosets_lemmas.T, ring_cosets_lemmas.+, ring_cosets_lemmas.*, ring_cosets_lemmas.zero].ring?(sets[ring_cosets_lemmas.T].fullset)")))("ring_homomorphism_lemmas" ring_homomorphism_lemmas IMP_ring_basic_properties_TCC1 0 (IMP_ring_basic_properties_TCC1-1 nil 3852714674 ("" (lemma "R1_is_ring") (("" (propax) nil nil)) nil) ((R1_is_ring formula-decl nil ring_homomorphism_lemmas nil)) nil (IMP_ring_basic_properties assuming "ring_basic_properties[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1, ring_homomorphism_lemmas.zero1].ring_basic_properties" "fullset_is_ring: ASSUMPTION ring_def[ring_basic_properties.T, ring_basic_properties.+, ring_basic_properties.*, ring_basic_properties.zero].ring?(sets[ring_basic_properties.T].fullset)")))("ring_homomorphism_lemmas" ring_homomorphism_lemmas IMP_ring_basic_properties_TCC2 0 (IMP_ring_basic_properties_TCC2-1 nil 3852714674 ("" (lemma "R2_is_ring") (("" (propax) nil nil)) nil) ((R2_is_ring formula-decl nil ring_homomorphism_lemmas nil)) nil (IMP_ring_basic_properties assuming "ring_basic_properties[ring_homomorphism_lemmas.T2, ring_homomorphism_lemmas.s2, ring_homomorphism_lemmas.p2, ring_homomorphism_lemmas.zero2].ring_basic_properties" "fullset_is_ring: ASSUMPTION ring_def[ring_basic_properties.T, ring_basic_properties.+, ring_basic_properties.*, ring_basic_properties.zero].ring?(sets[ring_basic_properties.T].fullset)")))("ring_center" ring_center IMP_ring_basic_properties_TCC1 0 (IMP_ring_basic_properties_TCC1-1 nil 3808759749 ("" (rewrite "fullset_is_ring") nil nil) ((fullset_is_ring formula-decl nil ring_center nil)) nil (IMP_ring_basic_properties assuming "ring_basic_properties[ring_center.T, ring_center.+, ring_center.*, ring_center.zero].ring_basic_properties" "fullset_is_ring: ASSUMPTION ring_def[ring_basic_properties.T, ring_basic_properties.+, ring_basic_properties.*, ring_basic_properties.zero].ring?(sets[ring_basic_properties.T].fullset)")))("ring_unit" ring_unit IMP_ring_ideal_TCC1 0 (IMP_ring_ideal_TCC1-1 nil 3861799364 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (flatten) nil nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (fullset_is_ring_with_one formula-decl nil ring_unit nil)) nil (IMP_ring_ideal assuming "ring_ideal[ring_unit.T, ring_unit.+, ring_unit.*, ring_unit.zero].ring_ideal" "fullset_is_ring: ASSUMPTION ring_def[ring_ideal.T, ring_ideal.+, ring_ideal.*, ring_ideal.zero].ring?(sets[ring_ideal.T].fullset)")))("ring_unit" ring_unit IMP_ring_with_one_TCC1 0 (IMP_ring_with_one_TCC1-1 nil 3861799364 ("" (rewrite "fullset_is_ring_with_one") nil nil) ((fullset_is_ring_with_one formula-decl nil ring_unit nil)) nil (IMP_ring_with_one assuming "ring_with_one[ring_unit.T, ring_unit.+, ring_unit.*, ring_unit.zero, ring_unit.one].ring_with_one" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one.T, ring_with_one.+, ring_with_one.*, ring_with_one.zero, ring_with_one.one].ring_with_one?(sets[ring_with_one.T].fullset)")))("division_ring_extras" division_ring_extras IMP_ring_unit_TCC1 0 (IMP_ring_unit_TCC1-1 nil 3801236149 ("" (rewrite "fullset_is_ring_with_one") nil nil) ((fullset_is_ring_with_one formula-decl nil division_ring_extras nil)) nil (IMP_ring_unit assuming "ring_unit[division_ring_extras.T, division_ring_extras.+, division_ring_extras.*, division_ring_extras.zero, division_ring_extras.one].ring_unit" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_unit.T, ring_unit.+, ring_unit.*, ring_unit.zero, ring_unit.one].ring_with_one?(sets[ring_unit.T].fullset)")))("ring_zn" ring_zn IMP_quotient_rings_with_one_TCC1 0 (IMP_quotient_rings_with_one_TCC1-1 nil 3813420475 ("" (expand "ring_with_one?") (("" (expand "ring?") (("" (split) (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (split) (("1" (expand "monad?") (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand "inv_exists?") (("3" (skosimp) (("3" (inst 1 "-x!1") (("1" (assert) nil nil) ("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (expand "left_distributive?") (("4" (skosimp) (("4" (expand "restrict") (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (expand "right_distributive?") (("5" (skosimp) (("5" (expand "restrict") (("5" (propax) nil nil)) nil)) nil)) nil) ("6" (expand "monoid?") (("6" (expand "monad?") (("6" (split) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ring? const-decl "bool" ring_def nil) (right_distributive? const-decl "bool" operator_defs_more nil) (left_distributive? const-decl "bool" operator_defs_more nil) (int_times_int_is_int application-judgement "int" integers nil) (abelian_group? const-decl "bool" group_def nil) (monoid? const-decl "bool" monoid_def nil) (commutative? const-decl "bool" operator_defs nil) (inv_exists? const-decl "bool" group_def nil) (minus_int_is_int application-judgement "int" integers nil) (x!1 skolem-const-decl "(fullset[int])" ring_zn nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (associative? const-decl "bool" operator_defs nil) (monad? const-decl "bool" monad_def nil) (restrict const-decl "R" restrict nil) (identity? const-decl "bool" operator_defs nil) (fullset const-decl "set" sets nil) (member const-decl "bool" sets nil) (star_closed? const-decl "bool" groupoid_def nil) (int_plus_int_is_int application-judgement "int" integers nil) (group? const-decl "bool" group_def nil) (ring_with_one? const-decl "bool" ring_with_one_def nil)) nil (IMP_quotient_rings_with_one assuming "quotient_rings_with_one[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0, 1].quotient_rings_with_one" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[quotient_rings_with_one.T, quotient_rings_with_one.+, quotient_rings_with_one.*, quotient_rings_with_one.zero, quotient_rings_with_one.one].ring_with_one?(sets[quotient_rings_with_one.T].fullset)")))("product_finseq_sets_ring" product_finseq_sets_ring IMP_cartesian_product_quot_ring_TCC1 0 (IMP_cartesian_product_quot_ring_TCC1-1 nil 3796724087 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (assert) nil nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (fullset_is_ring_with_one formula-decl nil product_finseq_sets_ring nil)) nil (IMP_cartesian_product_quot_ring assuming "cartesian_product_quot_ring[product_finseq_sets_ring.T, product_finseq_sets_ring.+, product_finseq_sets_ring.*, product_finseq_sets_ring.zero].cartesian_product_quot_ring" "fullset_is_ring: ASSUMPTION ring_def[cartesian_product_quot_ring.T, cartesian_product_quot_ring.+, cartesian_product_quot_ring.*, cartesian_product_quot_ring.zero].ring?(sets[cartesian_product_quot_ring.T].fullset)")))("product_finseq_sets_ring" product_finseq_sets_ring IMP_ring_with_one_TCC1 0 (IMP_ring_with_one_TCC1-1 nil 3796724381 ("" (rewrite "fullset_is_ring_with_one") nil nil) ((fullset_is_ring_with_one formula-decl nil product_finseq_sets_ring nil)) nil (IMP_ring_with_one assuming "ring_with_one[product_finseq_sets_ring.T, product_finseq_sets_ring.+, product_finseq_sets_ring.*, product_finseq_sets_ring.zero, product_finseq_sets_ring.one].ring_with_one" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one.T, ring_with_one.+, ring_with_one.*, ring_with_one.zero, ring_with_one.one].ring_with_one?(sets[ring_with_one.T].fullset)")))("chinese_remainder_theorem_rings" chinese_remainder_theorem_rings IMP_product_finseq_sets_ring_TCC1 0 (IMP_product_finseq_sets_ring_TCC2-1 nil 3793737450 ("" (rewrite "fullset_is_ring_with_one") nil nil) ((fullset_is_ring_with_one formula-decl nil chinese_remainder_theorem_rings nil)) nil (IMP_product_finseq_sets_ring assuming "product_finseq_sets_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero, chinese_remainder_theorem_rings.one].product_finseq_sets_ring" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[product_finseq_sets_ring.T, product_finseq_sets_ring.+, product_finseq_sets_ring.*, product_finseq_sets_ring.zero, product_finseq_sets_ring.one].ring_with_one?(sets[product_finseq_sets_ring.T].fullset)")))("chinese_remainder_theorem_Z" chinese_remainder_theorem_Z IMP_chinese_remainder_theorem_rings_TCC1 0 (IMP_chinese_remainder_theorem_rings_TCC1-1 nil 3861799385 ("" (lemma "Z_commutative_ring_w_one") (("" (expand "commutative_ring_with_one?") (("" (flatten) (("" (hide -2) (("" (expand "Z") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((commutative_ring_with_one? const-decl "bool" ring_with_one_def nil) (Z const-decl "ring[int, restrict[[numfield, numfield], [int, int], numfield](+),
     restrict[[numfield, numfield], [int, int], numfield](*), 0]" ring_zn nil) (Z_commutative_ring_w_one formula-decl nil ring_zn nil)) nil (IMP_chinese_remainder_theorem_rings assuming "chinese_remainder_theorem_rings[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0, 1].chinese_remainder_theorem_rings" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero, chinese_remainder_theorem_rings.one].ring_with_one?(sets[chinese_remainder_theorem_rings.T].fullset)")))("finite_integral_domain" finite_integral_domain IMP_integral_domain_TCC1 0 (IMP_integral_domain_TCC1-1 nil 3793817342 ("" (rewrite "fullset_is_integral_domain") nil nil) ((fullset_is_integral_domain formula-decl nil finite_integral_domain nil)) nil))("finite_integral_domain" finite_integral_domain IMP_ring_nz_closed_TCC1 0 (IMP_ring_nz_closed_TCC1-1 nil 3793817342 ("" (lemma "fullset_is_integral_domain") (("" (expand "integral_domain?") (("" (expand "commutative_ring?") (("" (expand "ring_nz_closed?") (("" (prop) nil nil)) nil)) nil)) nil)) nil) ((integral_domain? const-decl "bool" integral_domain_def "algebra/") (ring_nz_closed? const-decl "bool" ring_nz_closed_def "algebra/") (commutative_ring? const-decl "bool" ring_def "algebra/") (fullset_is_integral_domain formula-decl nil finite_integral_domain nil)) nil))("finite_integral_domain" finite_integral_domain IMP_ring_with_one_basic_properties_TCC1 0 (IMP_ring_with_one_basic_properties_TCC1-1 nil 3793817342 ("" (lemma "fullset_is_ring_with_one") (("" (propax) nil nil)) nil) ((fullset_is_ring_with_one formula-decl nil finite_integral_domain nil)) nil))("ring_divides" ring_divides IMP_ring_with_id_one_generator_TCC1 0 (IMP_ring_with_id_one_generator_TCC1-1 nil 3840203950 ("" (lemma "fullset_is_ring_with_one") (("" (propax) nil nil)) nil) ((fullset_is_ring_with_one formula-decl nil ring_divides nil)) nil (IMP_ring_with_id_one_generator assuming "ring_with_id_one_generator[ring_divides.T, ring_divides.+, ring_divides.*, ring_divides.zero, ring_divides.one].ring_with_id_one_generator" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_id_one_generator.T, ring_with_id_one_generator.+, ring_with_id_one_generator.*, ring_with_id_one_generator.zero, ring_with_id_one_generator.one].ring_with_one?(sets[ring_with_id_one_generator.T].fullset)")))("ring_divides" ring_divides IMP_ring_nz_closed_aux_TCC1 0 (IMP_ring_nz_closed_aux_TCC1-1 nil 3840203950 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (flatten) nil nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (fullset_is_ring_with_one formula-decl nil ring_divides nil)) nil (IMP_ring_nz_closed_aux assuming "ring_nz_closed_aux[ring_divides.T, ring_divides.+, ring_divides.*, ring_divides.zero].ring_nz_closed_aux" "fullset_is_ring: ASSUMPTION ring_def[ring_nz_closed_aux.T, ring_nz_closed_aux.+, ring_nz_closed_aux.*, ring_nz_closed_aux.zero].ring?(sets[ring_nz_closed_aux.T].fullset)")))("ring_divides" ring_divides IMP_op_finseq_TCC1 0 (IMP_op_finseq_TCC1-1 nil 3840203950 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (expand "ring?") (("" (expand "abelian_group?") (("" (expand "group?") (("" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (abelian_group? const-decl "bool" group_def nil) (group? const-decl "bool" group_def nil) (ring? const-decl "bool" ring_def nil) (fullset_is_ring_with_one formula-decl nil ring_divides nil)) nil (IMP_op_finseq assuming "op_finseq[ring_divides.T, ring_divides.*, ring_divides.one].op_finseq" "fullset_is_monoid: ASSUMPTION monoid_def[op_finseq.T, op_finseq.*, op_finseq.one].monoid?(sets[op_finseq.T].fullset)")))("ring_prime_ideal" ring_prime_ideal IMP_ring_one_generator_TCC1 0 (IMP_ring_one_generator_TCC1-1 nil 3793905401 ("" (rewrite "fullset_is_ring") nil nil) ((fullset_is_ring formula-decl nil ring_prime_ideal nil)) nil (IMP_ring_one_generator assuming "ring_one_generator[ring_prime_ideal.T, ring_prime_ideal.+, ring_prime_ideal.*, ring_prime_ideal.zero].ring_one_generator" "fullset_is_ring: ASSUMPTION ring_def[ring_one_generator.T, ring_one_generator.+, ring_one_generator.*, ring_one_generator.zero].ring?(sets[ring_one_generator.T].fullset)")))("ring_with_one_prime_ideal" ring_with_one_prime_ideal IMP_ring_prime_ideal_TCC1 0 (IMP_ring_prime_ideal_TCC1-1 nil 3856964765 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (flatten) nil nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (fullset_is_ring_with_one formula-decl nil ring_with_one_prime_ideal nil)) nil (IMP_ring_prime_ideal assuming "ring_prime_ideal[ring_with_one_prime_ideal.T, ring_with_one_prime_ideal.+, ring_with_one_prime_ideal.*, ring_with_one_prime_ideal.zero].ring_prime_ideal" "fullset_is_ring: ASSUMPTION ring_def[ring_prime_ideal.T, ring_prime_ideal.+, ring_prime_ideal.*, ring_prime_ideal.zero].ring?(sets[ring_prime_ideal.T].fullset)")))("ring_with_one_prime_ideal" ring_with_one_prime_ideal IMP_quotient_rings_with_one_TCC1 0 (IMP_quotient_rings_with_one_TCC1-1 nil 3856964765 ("" (lemma "fullset_is_ring_with_one") (("" (propax) nil nil)) nil) ((fullset_is_ring_with_one formula-decl nil ring_with_one_prime_ideal nil)) nil (IMP_quotient_rings_with_one assuming "quotient_rings_with_one[ring_with_one_prime_ideal.T, ring_with_one_prime_ideal.+, ring_with_one_prime_ideal.*, ring_with_one_prime_ideal.zero, ring_with_one_prime_ideal.one].quotient_rings_with_one" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[quotient_rings_with_one.T, quotient_rings_with_one.+, quotient_rings_with_one.*, quotient_rings_with_one.zero, quotient_rings_with_one.one].ring_with_one?(sets[quotient_rings_with_one.T].fullset)")))("ring_maximal_ideal" ring_maximal_ideal IMP_ring_prime_ideal_TCC1 0 (IMP_ring_prime_ideal_TCC1-1 nil 3793987454 ("" (rewrite "fullset_is_ring") nil nil) ((fullset_is_ring formula-decl nil ring_maximal_ideal nil)) nil (IMP_ring_prime_ideal assuming "ring_prime_ideal[ring_maximal_ideal.T, ring_maximal_ideal.+, ring_maximal_ideal.*, ring_maximal_ideal.zero].ring_prime_ideal" "fullset_is_ring: ASSUMPTION ring_def[ring_prime_ideal.T, ring_prime_ideal.+, ring_prime_ideal.*, ring_prime_ideal.zero].ring?(sets[ring_prime_ideal.T].fullset)")))("ring_with_one_maximal_ideal" ring_with_one_maximal_ideal IMP_ring_with_one_prime_ideal_TCC1 0 (IMP_ring_with_one_prime_ideal_TCC1-1 nil 3861799401 ("" (lemma "fullset_is_ring_with_one") (("" (propax) nil nil)) nil) ((fullset_is_ring_with_one formula-decl nil ring_with_one_maximal_ideal nil)) nil (IMP_ring_with_one_prime_ideal assuming "ring_with_one_prime_ideal[ring_with_one_maximal_ideal.T, ring_with_one_maximal_ideal.+, ring_with_one_maximal_ideal.*, ring_with_one_maximal_ideal.zero, ring_with_one_maximal_ideal.one].ring_with_one_prime_ideal" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one_prime_ideal.T, ring_with_one_prime_ideal.+, ring_with_one_prime_ideal.*, ring_with_one_prime_ideal.zero, ring_with_one_prime_ideal.one].ring_with_one?(sets[ring_with_one_prime_ideal.T].fullset)")))("ring_with_one_maximal_ideal" ring_with_one_maximal_ideal IMP_ring_maximal_ideal_TCC1 0 (IMP_ring_maximal_ideal_TCC1-1 nil 3861799401 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (flatten) nil nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (fullset_is_ring_with_one formula-decl nil ring_with_one_maximal_ideal nil)) nil (IMP_ring_maximal_ideal assuming "ring_maximal_ideal[ring_with_one_maximal_ideal.T, ring_with_one_maximal_ideal.+, ring_with_one_maximal_ideal.*, ring_with_one_maximal_ideal.zero].ring_maximal_ideal" "fullset_is_ring: ASSUMPTION ring_def[ring_maximal_ideal.T, ring_maximal_ideal.+, ring_maximal_ideal.*, ring_maximal_ideal.zero].ring?(sets[ring_maximal_ideal.T].fullset)")))("ring_general_results" ring_general_results IMP_ring_with_one_basic_properties_TCC1 0 (IMP_ring_with_one_basic_properties_TCC1-1 nil 3798279991 ("" (rewrite "fullset_is_ring_with_one") nil nil) ((fullset_is_ring_with_one formula-decl nil ring_general_results nil)) nil (IMP_ring_with_one_basic_properties assuming "ring_with_one_basic_properties[ring_general_results.T, ring_general_results.+, ring_general_results.*, ring_general_results.zero, ring_general_results.one].ring_with_one_basic_properties" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one_basic_properties.T, ring_with_one_basic_properties.+, ring_with_one_basic_properties.*, ring_with_one_basic_properties.zero, ring_with_one_basic_properties.one].ring_with_one?(sets[ring_with_one_basic_properties.T].fullset)")))("ring_general_results" ring_general_results IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3798279991 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (assert) nil nil)) nil)) nil) (nil (fullset_is_ring_with_one formula-decl nil ring_general_results nil)) nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[ring_general_results.T, ring_general_results.+, ring_general_results.*, ring_general_results.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("ring_principal_ideal_domain" ring_principal_ideal_domain IMP_ring_with_one_maximal_ideal_TCC1 0 (IMP_ring_with_one_maximal_ideal_TCC1-1 nil 3856627874 ("" (rewrite "fullset_is_ring_with_one") nil nil) ((fullset_is_ring_with_one formula-decl nil ring_principal_ideal_domain nil)) nil (IMP_ring_with_one_maximal_ideal assuming "ring_with_one_maximal_ideal[ring_principal_ideal_domain.T, ring_principal_ideal_domain.+, ring_principal_ideal_domain.*, ring_principal_ideal_domain.zero, ring_principal_ideal_domain.one].ring_with_one_maximal_ideal" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one_maximal_ideal.T, ring_with_one_maximal_ideal.+, ring_with_one_maximal_ideal.*, ring_with_one_maximal_ideal.zero, ring_with_one_maximal_ideal.one].ring_with_one?(sets[ring_with_one_maximal_ideal.T].fullset)")))("ring_principal_ideal_domain" ring_principal_ideal_domain IMP_ring_principal_ideal_TCC1 0 (IMP_ring_principal_ideal_TCC1-1 nil 3856627874 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (assert) nil nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (fullset_is_ring_with_one formula-decl nil ring_principal_ideal_domain nil)) nil (IMP_ring_principal_ideal assuming "ring_principal_ideal[ring_principal_ideal_domain.T, ring_principal_ideal_domain.+, ring_principal_ideal_domain.*, ring_principal_ideal_domain.zero].ring_principal_ideal" "fullset_is_ring: ASSUMPTION ring_def[ring_principal_ideal.T, ring_principal_ideal.+, ring_principal_ideal.*, ring_principal_ideal.zero].ring?(sets[ring_principal_ideal.T].fullset)")))("euclidean_domain" euclidean_domain IMP_ring_with_one_basic_properties_TCC1 0 (IMP_ring_with_one_basic_properties_TCC1-1 nil 3855928571 ("" (lemma "fullset_is_ring_with_one") (("" (propax) nil nil)) nil) ((fullset_is_ring_with_one formula-decl nil euclidean_domain nil)) nil (IMP_ring_with_one_basic_properties assuming "ring_with_one_basic_properties[euclidean_domain.T, euclidean_domain.+, euclidean_domain.*, euclidean_domain.zero, euclidean_domain.one].ring_with_one_basic_properties" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one_basic_properties.T, ring_with_one_basic_properties.+, ring_with_one_basic_properties.*, ring_with_one_basic_properties.zero, ring_with_one_basic_properties.one].ring_with_one?(sets[ring_with_one_basic_properties.T].fullset)")))("euclidean_domain" euclidean_domain IMP_euclidean_ring_TCC1 0 (IMP_euclidean_ring_TCC1-1 nil 3858611879 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (flatten) nil nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (fullset_is_ring_with_one formula-decl nil euclidean_domain nil)) nil (IMP_euclidean_ring assuming "euclidean_ring[euclidean_domain.T, euclidean_domain.+, euclidean_domain.*, euclidean_domain.zero].euclidean_ring" "fullset_is_ring: ASSUMPTION ring_def[euclidean_ring.T, euclidean_ring.+, euclidean_ring.*, euclidean_ring.zero].ring?(sets[euclidean_ring.T].fullset)")))("ring_euclidean_algorithm" ring_euclidean_algorithm IMP_euclidean_domain_TCC1 0 (IMP_euclidean_domain_TCC1-1 nil 3859538045 ("" (lemma "fullset_is_ring_with_one") (("" (propax) nil nil)) nil) ((fullset_is_ring_with_one formula-decl nil ring_euclidean_algorithm nil)) nil (IMP_euclidean_domain assuming "euclidean_domain[ring_euclidean_algorithm.T, ring_euclidean_algorithm.+, ring_euclidean_algorithm.*, ring_euclidean_algorithm.zero, ring_euclidean_algorithm.one].euclidean_domain" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[euclidean_domain.T, euclidean_domain.+, euclidean_domain.*, euclidean_domain.zero, euclidean_domain.one].ring_with_one?(sets[euclidean_domain.T].fullset)")))("quaternions" quaternions IMP_ring_with_one_TCC1 0 (IMP_ring_with_one_TCC1-1 nil 3875632953 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_with_one assuming "ring_with_one[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].ring_with_one" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one.T, ring_with_one.+, ring_with_one.*, ring_with_one.zero, ring_with_one.one].ring_with_one?(sets[ring_with_one.T].fullset)")))("quaternions_def" quaternions_def IMP_group_TCC1 0 (IMP_group_TCC1-1 nil 3875712326 ("" (assuming-tcc) nil nil) nil nil (IMP_group assuming "group[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group" "fullset_is_group: ASSUMPTION group_def[group.T, group.*, group.one].group?(sets[group.T].fullset)")))("quaternions_def" quaternions_def basis_quat 0 (basis_quat-1 nil 3875712339 ("" (skeep) (("" (expand* *) (("" (expand* +) (("" (expand "one_q") (("" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3875632953 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions sqr_i 0 (sqr_i-1 nil 3875632953 ("" (grind) nil nil) ((b formal-const-decl "T" quaternions nil) (a formal-const-decl "T" quaternions nil) (one formal-const-decl "T" quaternions nil) (zero formal-const-decl "T" quaternions nil) (* formal-const-decl "[T, T -> T]" quaternions nil) (+ formal-const-decl "[T, T -> T]" quaternions nil) (T formal-nonempty-type-decl nil quaternions nil) (i const-decl "quat" quaternions_def nil) (times_zero formula-decl nil ring nil) (one_times formula-decl nil ring_with_one nil) (zero_plus formula-decl nil ring nil) (zero_times formula-decl nil ring nil) (plus_zero formula-decl nil ring nil) (negate_zero formula-decl nil ring nil)) shostak))("quaternions" quaternions sqr_j 0 (sqr_j-1 nil 3875633081 ("" (grind) nil nil) ((b formal-const-decl "T" quaternions nil) (a formal-const-decl "T" quaternions nil) (one formal-const-decl "T" quaternions nil) (zero formal-const-decl "T" quaternions nil) (* formal-const-decl "[T, T -> T]" quaternions nil) (+ formal-const-decl "[T, T -> T]" quaternions nil) (T formal-nonempty-type-decl nil quaternions nil) (j const-decl "quat" quaternions_def nil) (times_zero formula-decl nil ring nil) (zero_times formula-decl nil ring nil) (plus_zero formula-decl nil ring nil) (one_times formula-decl nil ring_with_one nil) (zero_plus formula-decl nil ring nil) (negate_zero formula-decl nil ring nil)) shostak))("quaternions" quaternions ji_prod 0 (ji_prod-1 nil 3875633099 ("" (grind) nil nil) ((b formal-const-decl "T" quaternions nil) (a formal-const-decl "T" quaternions nil) (one formal-const-decl "T" quaternions nil) (zero formal-const-decl "T" quaternions nil) (* formal-const-decl "[T, T -> T]" quaternions nil) (+ formal-const-decl "[T, T -> T]" quaternions nil) (T formal-nonempty-type-decl nil quaternions nil) (j const-decl "quat" quaternions_def nil) (i const-decl "quat" quaternions_def nil) (times_zero formula-decl nil ring nil) (zero_times formula-decl nil ring nil) (plus_zero formula-decl nil ring nil) (negate_zero formula-decl nil ring nil) (one_times formula-decl nil ring_with_one nil) (zero_plus formula-decl nil ring nil) (k const-decl "quat" quaternions_def nil) (inv const-decl "quat" quaternions_def nil)) shostak))("quaternions_def" quaternions_def one_sc 0 (one_sc-1 nil 3876427717 ("" (skeep) (("" (expand *) (("" (grind) (("" (decompose-equality) (("1" (grind) (("1" (grind) (("1" (grind) (("1" (grind) (("1" (grind) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("quaternions_def" quaternions_def IMP_group_TCC1 0 (IMP_group_TCC1-1 nil 3876428377 ("" (assuming-tcc) nil nil) nil nil (IMP_group assuming "group[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group" "fullset_is_group: ASSUMPTION group_def[group.T, group.*, group.one].group?(sets[group.T].fullset)")))("quaternions" quaternions one_q_times 0 (one_q_times-1 nil 3875640340 ("" (skeep) (("" (expand "*") (("" (decompose-equality) (("1" (grind) (("1" (case "fullset_is_ring_with_one") (("1" (expand "fullset_is_ring_with_one") (("1" (copy -1) (("1" (expand "ring_with_one?" -2) (("1" (rewrite* "zero_times[T,+,*,zero]") (("1" (assert) (("1" (rewrite "one_times[T,+,*,zero,one]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "fullset_is_ring_with_one") (("2" (expand "fullset_is_ring_with_one") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (lemma "fullset_is_ring_with_one") (("2" (copy -1) (("2" (expand "ring_with_one?" -2) (("2" (rewrite* "zero_times[T,+,*,zero]") (("2" (assert) (("2" (rewrite "one_times[T,+,*,zero,one]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) (("3" (lemma "fullset_is_ring_with_one") (("3" (copy -1) (("3" (expand "ring_with_one?" -2) (("3" (rewrite* "zero_times[T,+,*,zero]") (("3" (assert) (("3" (rewrite "one_times[T,+,*,zero,one]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) (("4" (lemma "fullset_is_ring_with_one") (("4" (copy -1) (("4" (expand "ring_with_one?" -2) (("4" (rewrite* "zero_times[T,+,*,zero]") (("4" (assert) (("4" (rewrite "one_times[T,+,*,zero,one]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (one_times formula-decl nil ring_with_one nil) (TRUE const-decl "bool" booleans nil) (inv_one formula-decl nil group nil) (one_right formula-decl nil group nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (fullset const-decl "set" sets nil) (zero_times formula-decl nil ring nil) (fullset_is_ring_with_one formula-decl nil quaternions nil) (T formal-nonempty-type-decl nil quaternions nil) (+ formal-const-decl "[T, T -> T]" quaternions nil) (* formal-const-decl "[T, T -> T]" quaternions nil) (zero formal-const-decl "T" quaternions nil) (one formal-const-decl "T" quaternions nil) (a formal-const-decl "T" quaternions nil) (b formal-const-decl "T" quaternions nil) (quat type-eq-decl nil quaternions_def nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (one_q const-decl "quat" quaternions_def nil)) shostak))("quaternions" quaternions times_one_q 0 (times_one_q-1 nil 3875710927 ("" (skeep) (("" (expand "*") (("" (decompose-equality) (("1" (grind) (("1" (case "fullset_is_ring_with_one") (("1" (expand "fullset_is_ring_with_one") (("1" (copy -1) (("1" (expand "ring_with_one?" -2) (("1" (rewrite* "times_zero[T,+,*,zero]") (("1" (assert) (("1" (rewrite "times_one[T,+,*,zero,one]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "fullset_is_ring_with_one") (("2" (expand "fullset_is_ring_with_one") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (lemma "fullset_is_ring_with_one") (("2" (copy -1) (("2" (expand "ring_with_one?" -2) (("2" (rewrite* "times_zero[T,+,*,zero]") (("2" (assert) (("2" (rewrite* "zero_times[T,+,*,zero]") (("2" (assert) (("2" (rewrite "times_one[T,+,*,zero,one]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) (("3" (lemma "fullset_is_ring_with_one") (("3" (copy -1) (("3" (expand "ring_with_one?" -2) (("3" (rewrite* "times_zero[T,+,*,zero]") (("3" (assert) (("3" (rewrite "times_one[T,+,*,zero,one]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) (("4" (lemma "fullset_is_ring_with_one") (("4" (copy -1) (("4" (expand "ring_with_one?" -2) (("4" (rewrite* "times_zero[T,+,*,zero]") (("4" (assert) (("4" (rewrite "times_one[T,+,*,zero,one]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((zero_times formula-decl nil ring nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (inv_one formula-decl nil group nil) (times_one formula-decl nil ring_with_one nil) (TRUE const-decl "bool" booleans nil) (one_right formula-decl nil group nil) (one_left formula-decl nil group nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (fullset const-decl "set" sets nil) (times_zero formula-decl nil ring nil) (fullset_is_ring_with_one formula-decl nil quaternions nil) (T formal-nonempty-type-decl nil quaternions nil) (+ formal-const-decl "[T, T -> T]" quaternions nil) (* formal-const-decl "[T, T -> T]" quaternions nil) (zero formal-const-decl "T" quaternions nil) (one formal-const-decl "T" quaternions nil) (a formal-const-decl "T" quaternions nil) (b formal-const-decl "T" quaternions nil) (quat type-eq-decl nil quaternions_def nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (one_q const-decl "quat" quaternions_def nil)) shostak))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3877018104 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3877078604 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3877079877 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions ji_prod 0 (ji_prod-1 nil 3877078926 ("" (rewrite "ij_is_k") (("" (rewrite "ji_prod") nil nil)) nil) ((ji_prod formula-decl nil quaternions_def nil) (b formal-const-decl "T" quaternions nil) (a formal-const-decl "T" quaternions nil) (one formal-const-decl "T" quaternions nil) (zero formal-const-decl "T" quaternions nil) (* formal-const-decl "[T, T -> T]" quaternions nil) (+ formal-const-decl "[T, T -> T]" quaternions nil) (T formal-nonempty-type-decl nil quaternions nil) (ij_is_k formula-decl nil quaternions_def nil)) shostak))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3877093936 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3877093936 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3877098065 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3877098065 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3878200484 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3878200484 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3878200484 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3878218212 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3878236611 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3878236611 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3878236611 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3878301574 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3878302527 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3878302527 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3878302527 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3878909874 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3878911087 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3878911087 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3878911087 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3881846528 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3881929290 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3881929290 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3881929290 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3881934063 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions T_TCC2 0 (T_TCC2-1 nil 3881846528 ("" (subtype-tcc) nil nil) nil nil (T subtype "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].*(quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].*(quaternions.q, quaternions.v), quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].conjugate(quaternions.q))" "(quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].pure_quat)")))("quaternions" quaternions T_is_linear_TCC1 0 (T_is_linear_TCC1-1 nil 3881846528 ("" (subtype-tcc) nil nil) nil nil (T_is_linear subtype "(quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].+)(quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].*(quaternions.c, quaternions.v), quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].*(quaternions.d, quaternions.w))" "(quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].pure_quat)")))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3881937190 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3881937190 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3881937190 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3882539928 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("division_ring_def" division_ring_def division_ring?_TCC1 0 (division_ring?_TCC1-1 nil 3293998727 ("" (skosimp*) (("" (typepred "x1!1`1") (("" (typepred "x1!1`2") (("" (postpone) nil nil)) nil)) nil)) nil) nil shostak))("division_ring_def" division_ring_def division_ring?_TCC2 0 (division_ring?_TCC2-1 nil 3293998727 ("" (postpone) nil nil) nil shostak))("division_ring_def" division_ring_def division_ring?_TCC3 0 (division_ring?_TCC3-1 nil 3293998727 ("" (postpone) nil nil) nil shostak))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3882540429 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3882540429 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3882540429 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3882991119 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions move_three_times 0 (move_three_times-1 nil 3883212979 ("" (skeep) (("" (lemma times_commutative) (("" (inst -1 "s1 * s2" "s3") (("" (replaces) (("" (rewrite times_associative) nil nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" quaternions nil) (* formal-const-decl "[T, T -> T]" quaternions nil) (+ formal-const-decl "[T, T -> T]" quaternions nil) (T formal-nonempty-type-decl nil quaternions nil) (times_commutative formula-decl nil commutative_ring nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (times_associative formula-decl nil ring nil)) shostak))("quaternions" quaternions move_four_times 0 (move_four_times-1 nil 3883213279 ("" (skeep) (("" (lemma move_three_times) (("" (inst -1 "s1 * s2" "s3" "s4") (("" (replaces) (("" (rewrite* times_associative) nil nil)) nil)) nil)) nil)) nil) ((move_three_times formula-decl nil quaternions nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (zero formal-const-decl "T" quaternions nil) (+ formal-const-decl "[T, T -> T]" quaternions nil) (times_associative formula-decl nil ring nil) (* formal-const-decl "[T, T -> T]" quaternions nil) (T formal-nonempty-type-decl nil quaternions nil)) shostak))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3883213681 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3883213681 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3883213681 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3883213817 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3883214273 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3883214273 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3883214273 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3883214499 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3883580440 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3883580440 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3883580440 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3883747029 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3883747687 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3883747687 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3883747687 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3883749095 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3883751988 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3883751988 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3883751988 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3883753029 ("" (lemma "fullset_is_field") (("" (expand "field?") (("" (expand "division_ring?") (("" (expand "ring_with_one?") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((field? const-decl "bool" field_def nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (division_ring? const-decl "bool" division_ring_def nil) (fullset_is_field formula-decl nil quaternions nil)) nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions non_zero_red_norm 0 (non_zero_red_norm-1 nil 3884175302 ("" (skeep) (("" (expand "red_norm") (("" (postpone) nil nil)) nil)) nil) nil shostak))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3884179501 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3884179501 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3884179501 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3884179862 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions nz_pp_nz_sqr_pp 0 (nz_pp_nz_sqr_pp-1 nil 3884180821 ("" (skeep) (("" (prop) (("1" (expand "pure_part") (("1" (rewrite "q_prod_charac") (("1" (decompose-equality -1) (("1" (expand "zero_q") (("1" (split) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (rewrite "zero_q_times") nil nil)) nil)) nil)) nil) nil shostak))("quaternions" quaternions nz_q_nz_sqr 0 (nz_q_nz_sqr-1 nil 3884179505 ("" (skeep) (("" (prop) (("1" (rewrite "q_prod_charac") (("1" (grind) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (rewrite "zero_q_times") nil nil)) nil)) nil)) nil)) nil) nil shostak))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3884180817 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3884180817 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3884180817 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3884340134 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions times_fseq_TCC1 0 (times_fseq_TCC1-1 nil 3884340099 ("" (subtype-tcc) nil nil) nil nil (times_fseq subtype "0" "below[sq`length]")))("quaternions" quaternions times_fseq_TCC2 0 (times_fseq_TCC2-1 nil 3884340099 ("" (subtype-tcc) nil nil) nil nil (times_fseq subtype "0" "below[sq`length]")))("quaternions" quaternions times_fseq_TCC3 0 (times_fseq_TCC3-1 nil 3884340099 ("" (subtype-tcc) nil nil) nil nil (times_fseq subtype "(number_fields.-)(length(quaternions.sq), 1)" "nat")))("quaternions" quaternions times_fseq_TCC4 0 (times_fseq_TCC4-1 nil 3884340099 ("" (subtype-tcc) nil nil) nil nil (times_fseq subtype "finite_sequences[quaternions.T].^(quaternions.sq, (1, (number_fields.-)(length(quaternions.sq), 1)))" "{sq: finite_sequences[quaternions.T].finseq | reals.>(length(sq), 0)}")))("quaternions" quaternions times_fseq_TCC5 0 (times_fseq_TCC5-1 nil 3884340099 ("" (termination-tcc) nil nil) nil nil (times_fseq termination "quaternions.times_fseq(finite_sequences[quaternions.T].^(quaternions.sq, (1, (number_fields.-)(length(quaternions.sq), 1))))" "nil")))("quaternions" quaternions heading_fseq_TCC1 0 (heading_fseq_TCC1-1 nil 3884340099 ("" (subtype-tcc) nil nil) nil nil (heading_fseq subtype "(number_fields.+)(quaternions.i, 1)" "below[sq`length]")))("quaternions" quaternions times_o_fseq_TCC1 0 (times_o_fseq_TCC1-1 nil 3884342268 ("" (subtype-tcc) nil nil) nil nil (times_o_fseq subtype "finite_sequences[quaternions.T].o(quaternions.s1, quaternions.s2)" "{sq: finite_sequences[quaternions.T].finseq | reals.>(length(sq), 0)}")))("quaternions" quaternions times_o_fseq 0 (times_o_fseq-1 nil 3884342294 ("" (measure-induct+ "length(s1)" ("s1")) (("1" (skeep) (("1" (expand "times_fseq" 1 2) (("1" (lift-if) (("1" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil) nil shostak))("quaternions" quaternions times_heading_fseq_TCC1 0 (times_heading_fseq_TCC1-1 nil 3884340099 ("" (subtype-tcc) nil nil) nil nil (times_heading_fseq subtype "quaternions.heading_fseq(quaternions.sq, quaternions.n)" "{sq: finite_sequences[quaternions.T].finseq | reals.>(length(sq), 0)}")))("quaternions" quaternions times_heading_fseq 0 (times_heading_fseq-1 nil 3884340135 ("" (measure-induct+ "length(sq)" ("sq")) (("1" (skeep) (("1" (case "n=0") (("1" (replaces -1) (("1" (hide -) (("1" (grind) (("1" (case "x!1 = (# length := length(x!1),
                     seq
                       := LAMBDA (i: below[length(x!1)]):
                  
          IF i > 0 THEN x!1`seq(i)
                            ELSE x!1`seq(0)
                            ENDIF #)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (grind) (("2" (decompose-equality) (("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (expand "times_fseq") (("2" (lift-if) (("2" (prop) (("1" (lift-if) (("1" (prop) (("1" (typepred "n") (("1" (grind) nil nil)) nil) ("2" (hide 2 3) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (hide 1) (("1" (grind) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil) nil shostak))("op_finseq" op_finseq IMP_monoid_TCC1 0 (IMP_monoid_TCC1-1 nil 3856964774 ("" (lemma "fullset_is_monoid") (("" (propax) nil nil)) nil) ((fullset_is_monoid formula-decl nil op_finseq nil)) nil (IMP_monoid assuming "monoid[op_finseq.T, op_finseq.*, op_finseq.one].monoid" "fullset_is_monoid: ASSUMPTION monoid_def[monoid.T, monoid.*, monoid.one].monoid?(sets[monoid.T].fullset)")))("op_finseq" op_finseq IMP_monoid_TCC1 0 (IMP_monoid_TCC1-1 nil 3884351573 ("" (assuming-tcc) nil nil) nil nil (IMP_monoid assuming "monoid[op_finseq.T, op_finseq.*, op_finseq.one].monoid" "fullset_is_monoid: ASSUMPTION monoid_def[monoid.T, monoid.*, monoid.one].monoid?(sets[monoid.T].fullset)")))("quaternions" quaternions red_norm_has_mult_inv_TCC1 0 (red_norm_has_mult_inv_TCC1-1 nil 3884175111 ("" (assuming-tcc) nil nil) nil nil (red_norm_has_mult_inv assuming "group[quaternions.T, quaternions.*, quaternions.one].group" "fullset_is_group: ASSUMPTION group_def[group.T, group.*, group.one].group?(sets[group.T].fullset)")))("quaternions" quaternions q_conj_vs_inv_TCC1 0 (q_conj_vs_inv_TCC1-1 nil 3878909378 ("" (assuming-tcc) nil nil) nil nil (q_conj_vs_inv assuming "group[quat[T, +, *, zero, one, a, b], quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].*, quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].one_q].group" "fullset_is_group: ASSUMPTION group_def[group.T, group.*, group.one].group?(sets[group.T].fullset)")))("quaternions" quaternions q_conj_vs_inv 0 (q_conj_vs_inv-1 nil 3881847708 ("" (skeep) (("" (typepred "inv[quat[T, +, *, zero, one, a, b], *, one_q](q)") (("" (hide -1) (("" (lemma "times_associative[quat,+,*,zero_q]") (("1" (inst -1 "inv[quat[T, +, *, zero, one, a, b], *, one_q](q)" "q" "conjugate(q)") (("1" (lemma "sc_F_commutes") (("1" (inst -1 "red_norm(q)" "inv[quat[T, +, *, zero, one, a, b], *, one_q](q)") (("1" (replaces -1) (("1" (expand "red_norm") (("1" (replaces -2) (("1" (rewrite "one_q_times") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "scalar_F") (("2" (rewrite "red_norm_charac") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "quat_is_ring_w_one") (("2" (expand "ring_with_one?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inv const-decl "{y | x * y = one AND y * x = one}" group nil) (one_q const-decl "quat" quaternions_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[quat, quat -> quat]" quaternions_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (quat type-eq-decl nil quaternions_def nil) (b formal-const-decl "T" quaternions nil) (a formal-const-decl "T" quaternions nil) (one formal-const-decl "T" quaternions nil) (zero formal-const-decl "T" quaternions nil) (* formal-const-decl "[T, T -> T]" quaternions nil) (+ formal-const-decl "[T, T -> T]" quaternions nil) (T formal-nonempty-type-decl nil quaternions nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (times_associative formula-decl nil ring nil) (+ const-decl "quat" quaternions_def nil) (zero_q const-decl "quat" quaternions_def nil) (fullset const-decl "set" sets nil) (ring? const-decl "bool" ring_def nil) (set type-eq-decl nil sets nil) (sc_F_commutes formula-decl nil quaternions nil) (red_norm_charac formula-decl nil quaternions nil) (TRUE const-decl "bool" booleans nil) (one_q_times formula-decl nil quaternions_def nil) (red_norm const-decl "quat" quaternions_def nil) (scalar_F const-decl "set[quat]" quaternions_def nil) (conjugate const-decl "quat" quaternions_def nil) (quat_is_ring_w_one formula-decl nil quaternions nil) (ring_with_one? const-decl "bool" ring_with_one_def nil)) shostak))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3884939154 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3884939154 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3884939154 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3884939229 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3884958699 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3884958699 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3884958699 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("quaternions" quaternions nz_q_nz_red_norm_TCC1 0 (nz_q_nz_red_norm_TCC1-1 nil 3884853781 ("" (assuming-tcc) nil nil) nil nil (nz_q_nz_red_norm assuming "group[quaternions.T, quaternions.*, quaternions.one].group" "fullset_is_group: ASSUMPTION group_def[group.T, group.*, group.one].group?(sets[group.T].fullset)")))("quaternions" quaternions nz_q_nz_red_norm 0 (nz_q_nz_red_norm-1 nil 3884176232 ("" (skeep) (("" (rewrite "red_norm_charac") (("" (expand "zero_q" -2) (("" (rewrite "plus_associative") (("" (rewrite* "negative_times") (("" (lemma "negate_plus") (("" (inst -1 "b * (q`z * q`z)" "a * (q`y * q`y)") (("" (replace -1 -3 rl) (("" (case "q`x * q`x + (a * b) * (q`t * q`t) = a * (q`y * q`y) + b * (q`z * q`z)") (("1" (hide -2 -4) (("1" (inst -2 "(q`y)" "(q`z)") (("1" (grind) (("1" (replace -1 1 rl) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("quaternions" quaternions nz_q_nz_red_norm_test 0 (nz_q_nz_red_norm_test-1 nil 3884869745 ("" (skeep) (("" (rewrite "red_norm_charac") (("" (expand "zero_q" -1) (("" (rewrite* "negative_times") (("" (lemma "negate_plus") (("" (inst -1 "b * (q`z * q`z)" "a * (q`y * q`y)") (("" (rewrite "plus_associative" -2) (("" (replace -1 -2 rl) (("" (hide -1) (("" (case-replace "b * (q`z * q`z) + a * (q`y * q`y) = a * (q`y * q`y)+ b * (q`z * q`z)") (("1" (hide -1) (("1" (inst-cp 1 "(q`y * q`y)" "(q`z * q`z)") (("1" (expand "^" 2) (("1" (expand* "power") (("1" (expand "power") (("1" (expand "power") (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("quaternions" quaternions pure_quat_charac_TCC1 0 (pure_quat_charac_TCC1-1 nil 3885305018 ("" (subtype-tcc) nil nil) nil nil (pure_quat_charac subtype "sets[quaternions.T].fullset" "(ring_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring?)")))("quaternions" quaternions IMP_field_TCC1 0 (IMP_field_TCC1-1 nil 3885380630 ("" (assuming-tcc) nil nil) nil nil (IMP_field assuming "field[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one].field" "fullset_is_field: ASSUMPTION field_def[field.T, field.+, field.*, field.zero, field.one].field?(sets[field.T].fullset)")))("quaternions" quaternions IMP_quaternions_def_TCC1 0 (IMP_quaternions_def_TCC1-1 nil 3885380630 ("" (assuming-tcc) nil nil) nil nil (IMP_quaternions_def assuming "quaternions_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero, quaternions.one, quaternions.a, quaternions.b].quaternions_def" "fullset_is_group: ASSUMPTION group_def[quaternions_def.T, quaternions_def.+, quaternions_def.zero].group?(sets[quaternions_def.T].fullset)")))("quaternions" quaternions IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3885380630 ("" (assuming-tcc) nil nil) nil nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[quaternions.T, quaternions.+, quaternions.*, quaternions.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))